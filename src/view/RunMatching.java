/*
SPAMDA: Software for Pre-processing and Analysis of Meteorological DAta to build datasets

Copyright (c) 2017-2021 by AYRNA Research Group. https://www.uco.es/ayrna/
    Authors: 
      Gómez-Orellana, A.M.; Fernández, J.C.; Dorado-Moreno, M.; Gutiérrez, P.A.; Hervás-Martínez, C.
      Building Suitable Datasets for Soft Computing and Machine Learning Techniques from Meteorological
       Data Integration: A Case Study for Predicting Significant Wave Height and Energy Flux.
      Energies 2021, 14, 468. https://doi.org/10.3390/en14020468                                                                       

This program is free software: you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software Foundation,
either version 3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program,
in the file COPYING. If not, see <http://www.gnu.org/licenses/>.

Additional permissions under GNU GPL version 3 section 7:
1. Redistributions of source code, with or without modification, must retain
the above full copyright notice as author attributions.

2. Redistributions in binary form and/or the use of the documentation,
with or without modification, must reproduce the above full copyright notice
as author attributions in the documentation and/or materials provided with
the distribution.

3. Modified versions of source code and/or documentation, as well as binary
distributions, must be marked in reasonable ways as different from the original version.

4. Neither name of copyright holders nor the names of its contributors may be used
to endorse or promote products derived from this software for publicity purposes
without specific prior written permission.

5. Redistribution and/or use of source code, binary format and documentation,
with or without modification, could require indemnification of licensors
and authors by anyone who conveys the material (or modified versions of it)
with contractual assumptions of liability to the recipient, for any liability
that these contractual assumptions directly impose on those licensors and authors.

SPAMDA uses some external libraries. You can see their respective notices about license,
copyright and disclaimer in the following files. For a more complete information about
such licenses, see the distributions provided by their authors:
-Library NetCDF Java, version 4.6.10
	Notice of license in the file NetCDF-LICENSE
-Library SLF4J, version 1.7.25
	Notice of license in the file SLF4J-LICENSE
-Library WEKA, version 3.8.1
	Notice of license in the file WEKA-LICENSE

Contact information:
Antonio Manuel Gomez Orellana, Mr.
email: am[dot]gomez[at]uco[dot]es
Address: University of Cordoba, Department of Computer Science
and Numerical Analysis, AYRNA Research Group, Rabanales Campus,
Einstein Building, 3rd floor. Road Madrid-Cadiz, Km 396-A.
14071 - Cordoba (Spain).

Juan Carlos Fernandez Caballero, PhD.
email: jfcaballero[at]uco[dot]es
Address: University of Cordoba, Department of Computer Science
and Numerical Analysis, AYRNA Research Group, Rabanales Campus,
Einstein Building, 3rd floor. Road Madrid-Cadiz, Km 396-A.
14071 - Cordoba (Spain).
 */

package view;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
import javax.swing.SwingWorker;
import model.DatasetFile;
import model.Instance;
import model.MatchingFinalDataset;
import model.ReanalysisFile;
import ucar.ma2.ArrayDouble;
import ucar.ma2.ArrayFloat;
import utils.Utils;
import xml.DatasetInformation;
import xml.MatchingInformation;
import xml.XMLFile;


/**
 * This class defines the view to start the process of creation of the final datasets.
 * 
 * The status of the process is showed and it can be cancelled by the user.
 * 
 */
public class RunMatching extends javax.swing.JDialog {       
        
    /* Generated by NetBeans. */
    private static final long serialVersionUID = -2283917901934753677L;
        
    
    /**
     * Configuration of the matching.
     */
    private MatchingInformation matchingConfig;

    
    /**
     * Latitude North of the selected buoy.
     */
    private double buoyLatitudeNorth;

    
    /**
     * Longitude East of the selected buoy.
     */
    private double buoyLongitudeEast;
    
    
    /**
     * Station ID of the selected buoy.
     */
    private String stationID;
    
    
    /**
     * Missing dates that were found in matching.
     */
    private ArrayList<String> missingDates;    
    
    
    /**
     * Indexes of instances that are missing dates.
     */
    private ArrayList<Integer> indexMissingInstances;

    
    /**
     * Matched databases created by the matching process.
     */
    private ArrayList<MatchingFinalDataset> matchedDataBases;
    
    
    /**
     * Databases's name created by the matching process.
     */
    private ArrayList<String> matchedDataBasesName;
       

    /**
     * Message to be displayed in case of error.
     */
    private String errorMessage;
    
    
    /**
     * To check if user pressed 'Cancel' button.
     */
    private boolean cancelPressed;    

    
    /**
     * Number of instances matched in matching process.
     */
    private int numOfInstancesMatched;
        
    
    /**
     * The SwingWorker.
     */
    private SwingWorker<Void, String> worker;
                   
            
    /**
     * Creates new dialog RunMatching
     * @param parent Jframe that creates this dialog.
     * @param modal Indicates if the dialog is modal or not.
     * @param matchingConfig Configuration of the matching.
     * @param buoyLatitudeNorth Latitude North of the selected buoy.
     * @param buoyLongitudeEast Longitude East of the selected buoy.
     * @param stationID Station ID of the selected buoy.
     */
    public RunMatching(java.awt.Frame parent, boolean modal, MatchingInformation matchingConfig, double buoyLatitudeNorth, double buoyLongitudeEast, String stationID) {
        
        super(parent, modal);
        initComponents();
        
        /* Initializes to default values. */

        this.matchingConfig=matchingConfig;
        this.buoyLatitudeNorth=buoyLatitudeNorth;
        this.buoyLongitudeEast=buoyLongitudeEast;
        this.errorMessage=null;
        this.cancelPressed=false;
        
        this.missingDates=null;
        this.indexMissingInstances=new ArrayList<>();
        this.matchedDataBases=new ArrayList<>();
        this.matchedDataBasesName=new ArrayList<>();  
        this.stationID = stationID;
        
        this.numOfInstancesMatched=0;
        
    }
    
    
    /* Methods of the class */            
        
    
    /**
     * Gets True if user selected 'Include missing dates' or False if not.
     * @return True if user selected 'Include missing dates' or False if not.
     */
    private boolean getIncludeMissingDates(){
        
        return this.matchingConfig.getIncludeMissingDates();
        
    }

    
    /**
     * Gets True if user selected 'Flux of energy' as output or False if not.
     * @return True if user selected 'Flux of energy' as output or False if not.
     */
    private boolean getCalculateFluxOfEnergy(){
        
        return this.matchingConfig.getCalculateFluxOfEnergy();
        
    }    
    

    /**
     * Gets dataset file's path to use.
     * @return Dataset file's path to use.
     */
    private String getDatasetFilePath(){
        
        return this.matchingConfig.getDatasetFilePath();
        
    }
   
    
    /**
     * Gets the type (Dataset/Preprocessed) of the dataset file to use.
     * @return the type (Dataset/Preprocessed) of the dataset file to use.
     */
    private String getDatasetFileType(){
        
        return this.matchingConfig.getTypeDatasetFile();
        
    }
       

    /**
     * Gets the name of the attribute to predict.
     * @return the name of the attribute to predict.
     */
    private String getAttributeNameToPredict(){
        
        return this.matchingConfig.getAttributeNameToPredict();
        
    }           
    
    
    /**
     * Gets the output files to create.
     * @return The output files to create.
     */
    private int getOutputFilesToCreate(){
        
        return this.matchingConfig.getOutputFilesToCreate();
        
    }       
        
    
    /**
     * Gets the reanalysis data's files to use.
     * @return The reanalysis data's files to use.
     */     
    private ArrayList<String> getReanalysisFiles() {
        
        return this.matchingConfig.getReanalysisFiles();
    }

    
    /**
     * Gets the variables of the buoy to use.
     * @return The variables of the buoy to use.
     */     
    private ArrayList<String> getBuoyVariables() {
        
        return this.matchingConfig.getBuoyVariables();
    }
                   

    /**
     * Gets the number of nearest geopoints to the buoy to consider.
     * @return The number of nearest geopoints to the buoy to consider.
     */
    private int getNumberOfNearestGeopointsToConsider(){
        
        return this.matchingConfig.getNumberOfNearestGeopointsToConsider();
        
    }
                            

    /**
     * Gets Latitude North of the buoy.
     * @return Latitude North of the buoy.
     */
    private double getBuoyLatitudeNorth(){
        
        return this.buoyLatitudeNorth;
        
    }        

    
    /**
     * Gets Longitude East of the buoy.
     * @return Longitude East of the buoy.
     */
    private double getBuoyLongitudeEast(){
        
        return this.buoyLongitudeEast;
        
    }    
    
    
    /**
     * Gets Station ID of the buoy.
     * @return Station ID of the buoy.
     */
    private String getStationID(){
        
        return this.stationID;
        
    }    
    
    
    /**
     * Return the missing dates that were found in matching.
     * @return The missing dates that were found in matching.
     */    
    public ArrayList<String> getMissingDates() {
        
        return this.missingDates;
        
    }        

    
    /**
     * Return the indexes of instances that are missing dates.
     * @return The indexes of instances that are missing dates.
     */    
    private ArrayList<Integer> getIndexMissingInstances() {
        
        return this.indexMissingInstances;
        
    }            


    /**
     * Sets the missing dates that were found in matching.
     * @param missingDates Missing dates that were found in matching.
     */    
    private void setMissingDates(ArrayList<String> missingDates) {
        
        this.missingDates=missingDates;
        
    }        
    
    
    /**
     * Returns matched databases created by the matching process.
     * @return Matched databases created by the matching process.
     */    
    public ArrayList<MatchingFinalDataset> getMatchedDataBases() {
        
        return this.matchedDataBases;
        
    }
    
        
    /**
     * Sets matched databases created by the matching process.
     * @param matchedDataBases Matched databases created by the matching process.
     */    
    private void setMatchedDataBases(ArrayList<MatchingFinalDataset> matchedDataBases) {
        
        this.matchedDataBases=matchedDataBases;

    }
        
    
    /**
     * Returns error message to be displayed.
     * @return Error message to be displayed.
     */    
    private String getErrorMessage() {
        
        return this.errorMessage;
        
    }
    
        
    /**
     * Sets error message to be displayed.
     * @param errorMessage Error message to be displayed.
     */    
    private void setErrorMessage(String errorMessage) {
        
        this.errorMessage=errorMessage;

    }

    
    /**
     * Returns true if user pressed 'Cancel' button or False if not.
     * @return True if user pressed 'Cancel' button or False if not.
     */    
    public boolean getPressedCancel() {
        
        return this.cancelPressed;
        
    }
    
        
    /**
     * Sets True that user pressed 'Cancel' button.
     */    
    private void setPressedCancel() {
        
        this.cancelPressed=true;

    }


    /**
     * Sets the number of the instances matched in matching process.
     * @param numOfInstancesMatched Number of the instances matched in matching process.
     */    
    private void setNumOfInstancesMatched(int numOfInstancesMatched) {
        
        this.numOfInstancesMatched=numOfInstancesMatched;

    }


    /**
     * Gets the number of the instances matched in matching process.
     * @return Number of the instances matched in matching process.
     */    
    private int getNumOfInstancesMatched() {
        
        return this.numOfInstancesMatched;

    }
    
    
    /**
     * Creates the SwingWorker and starts the matching process.
     */
    public void startMatching(){
    
        /* Enabale Cancel button. */
        btnCancel.setEnabled(true);
        
        /* Clear the text area that shows the status of the process. */
        jtaStatusSummary.setText("");
        
        /* Create the SwingWorker that will create the dataBases. */
        worker = new SwingWorker<Void, String>(){
        
            @Override
            protected Void doInBackground() throws Exception {
  
                /* Matching started. */
                publish("Matching process started.\n\n");
                
                
                /*
                
                    First: Creates database/s with reanalysis data files information.
                
                */                
                
                /* Checks number of databases to create. */
                switch (getOutputFilesToCreate()) {                
                                                        
                    case 0:
                
                        /* one database with weighted nearest geopoints mean. */

                        publish("   Creating one final dataset using weighted mean of nearest reanalysis nodes.\n");

                        if(createOneDatabase()==true){
                
                            /* Database created properly. */
                            publish("   Done.\n\n");
                
                        }else{
                
                            /* There was an error. The matching is cancelled. */
                            publish("   Error while creating final dataset: "+getErrorMessage()+"\n\n");
                            btnCancel.doClick();
                
                        }

                        break;

                    case 1:
                
                        /* 'n' databases (one per each geopoint) */

                        publish("   Creating 'n' final datasets (one per each reanalysis node).\n");

                        if(createNDatabases()==true){
                
                            /* Databases created properly. */
                            publish("   Done.\n\n");
                
                        }else{
                
                            /* There was an error. The matching is cancelled. */
                            publish("   Error while creating 'n' final datasets: "+getErrorMessage()+"\n\n");
                            btnCancel.doClick();
                
                        }

                        break;
                    
                    default:
                        
                        /* Option not defined. */
                        
                        publish("   Error. Output files number not defined.\n\n");
                        
                        /* Cancel the matching. */
                        btnCancel.doClick();
                        break;
                }
                
                
                /*
                
                    Second: Matching database/s with dataset information.
                
                */
                                
                
                /* Checks if there was an error or not. */
                if(isCancelled()==false){                
                    
                    publish("   Reading selected dataset and matching instances.\n");
                    
                    /* Matching instances. */
                    if(matchingInstances()==true){

                        /* Matching finished properly. */
                        
                        /* Shows missing dates found. */
                        
                        for(String missingDate: getMissingDates()){
                            
                            publish("       Missing date found: " + missingDate +"\n");
                        
                        }
                        
                        /* Checks if one instance was matched at least. */
                        if(getNumOfInstancesMatched()==0){
                            
                            /* None instance was matched. */
                            
                            publish("\n\n       Attention!! None instance was matched.\n");
                            btnCancel.doClick();
                        
                        }
                            
                        publish("   Done.\n\n");

                    }else{

                        /* There was an error. The matching is cancelled. */
                        publish("   Error while matching instances: "+getErrorMessage()+"\n\n");
                        btnCancel.doClick();
                    }
                    
                }
                
                
                /*
                
                    Third: Converts all matched final datasets to Weka format.
                
                */


                /* Checks if there was an error or not. */
                if(isCancelled()==false){

                    for(int i=0;i<getMatchedDataBases().size();i++){

                        /* Convert instances and attributes to Weka format */
                        getMatchedDataBases().get(i).converToWekaFormat();
                    }
                    
                }
                                                 
                /* The SwingWorker has finished the matching. */

                return null;
                
            }
            
            @Override
            protected void process(List<String> data){
                
                for(String line : data){
                    
                    /* Send information received about the process to status window. */
                    
                    jtaStatusSummary.append(line);
                }
                
            }
            

            @Override
            protected void done(){

                /* The macthing has finished. Need to check if it was cancelled or not. */

                if( isCancelled()){
                    
                    /* The matching was cancelled. */                    

                    jtaStatusSummary.append("\nMatching process cancelled.\n");
                    
                }else{
                    
                    /* The matching finished properly. */                    
                    
                    btnCancel.setEnabled(false);                    
                    jtaStatusSummary.append("\nMatching process finished properly.\n");
                    
                }
                
                /* This button allows the user to close the window and back to Matching tab. */
                btnOK.setEnabled(true);                                        
                
            }
        
        };
                
        /* SwingWorker starts matching process. */
        worker.execute();
    
    }
    
    
    
    /**
     * Creates one final dataset using weighted mean of nearest geopoints.
     * @return True if database was properly created or False if the process failed.
     */
    private boolean createOneDatabase(){
        
        /* Creates one database with weighted nearest geopoints mean. */
        
        boolean result=true;
        
        /* Utilities. */
        Utils util = new Utils();
        
        /* Matched database to create. */                
        MatchingFinalDataset matchedDatabase = new MatchingFinalDataset();        
                
        /* Reanalysis data files to use. */
        ArrayList<String> reanalysisFiles = getReanalysisFiles();
        
        /* Number of nearest geopoints to consider. */
        int numberOfNearestGeopointsToConsider = getNumberOfNearestGeopointsToConsider();
                
        /* Path to reanalysis files. */
        String path = System.getProperty("user.dir", ".")
              +File.separator+"DB"+File.separator+"reanalysisFiles"+File.separator;
        
        /* 
            Opens first reanalysis data file and gets:
                - number of instances
                - reanalysis dates
                - latitude size and data
                - longitude size and data
            This information is common to all reanalysis files received.
        */        

        /* Opens first reanalysis data file. */
        ReanalysisFile rf = new ReanalysisFile();

        if(rf.openFile(path+reanalysisFiles.get(0)) == true){
        
            /* Number of instances and reanalysis dates. */
            int numInstances=rf.getSizeVariable("time");
            ArrayDouble.D1 reanalysisDates = rf.getDataVariableTime();

            /* Adds variable time from reanalysis data file to matched database. */
            //matchedDatabase.addAttribute("time");
            matchedDatabase.addAttribute("DATE");

            /* Adds all values of variable time from reanalysis data file to matched database. */
            for (int i=0;i<numInstances && getPressedCancel()==false;i++){                

                /* Creates the instance and sets time value. */
                Instance instance=new Instance();

                    /* 
                        NetCDF establishes 1800-01-01 as date base, so it is necessary to 
                        convert to Unix seconds.
                    */

                    instance.addFieldValue(util.secondsFrom1800ToUnix(reanalysisDates.get(i)));

                /* Adds the instance. */
                matchedDatabase.addInstance(instance);
            }

            /* Latitude size and data. */
            int sizeLatitude=rf.getSizeVariable("lat");

            ArrayFloat.D1 latitudesAux = rf.getDataVariable("lat");
            double[] latitudesNorth=new double[sizeLatitude];

            for(int i=0;i<sizeLatitude;i++){

                /* NetCDF latitudes are in: Latitude North */
                latitudesNorth[i]=latitudesAux.get(i);
                
            }


            /* Longitude size and data. */
            int sizeLongitude=rf.getSizeVariable("lon");

            ArrayFloat.D1 longitudesAux = rf.getDataVariable("lon");
            double[] longitudesEast=new double[sizeLongitude];

            for(int i=0;i<sizeLongitude;i++){

                /* NetCDF longitudes are in: Longitude East */                
                longitudesEast[i]=longitudesAux.get(i);
                
            }

            /* Calculates weights depending on distance from buoy to each geopoint. */
            Double[][] weightsAndNearestGeopoints=calculateWeightsAndNearestGeopoints(latitudesNorth, longitudesEast, getBuoyLatitudeNorth(), getBuoyLongitudeEast(),numberOfNearestGeopointsToConsider);

            /* Closes file. */
            rf.closeFile();


            /*
                Opens each reanalysis file received and
                gets the data of the reanalysis variable that it contains.
            */
            
            for(int file=0;file<reanalysisFiles.size() && result == true && getPressedCancel()==false;file++){                

                /* Opens reanalysis data file. */
                rf = new ReanalysisFile();
                
                if(rf.openFile(path+reanalysisFiles.get(file))==true){
                    
                    /* Adds reanalysis variable name to matched database. */
                    matchedDatabase.addAttribute(rf.getReanalysisVariableName());

                    /* Gets size and data. */
                    int sizeReanalysisVariable = rf.getReanalysisVariableSize();
                    ArrayFloat.D3 dataReanalysisVariable = rf.getReanalysisVariableData();


                    /* Calculates weighted nearest geopoints mean of reanalysis variable data. */
                    for (int i=0;i<sizeReanalysisVariable && getPressedCancel()==false;i++) {                    

                        /* Value of reanalysis variable to store in matched database. */
                        double summation=0;

                        /* Only nearest geopoints are considered. */
                        for(int k=0;k<numberOfNearestGeopointsToConsider;k++){
                            
                            /* Gets index of nearest geopoint. */
                            int indexGeopoint=weightsAndNearestGeopoints[k][0].intValue();                        
                            
                            /* Gets latitude and longitude index of nearest geopoint. */
                            int latitude=indexGeopoint / sizeLongitude;
                            int longitude=indexGeopoint % sizeLongitude;
                            
                            /* Nearest geopoint: acumulate reanalysis variable weighted value. */
                            summation+=dataReanalysisVariable.get(i, latitude, longitude)*weightsAndNearestGeopoints[k][1];
                            
                        }

                        /* Adds reanalysis variable weighted value calculated. */
                        matchedDatabase.getInstance(i).addFieldValue(summation);                

                    }

                    /* Closes file. */
                    rf.closeFile();

                }else{
                    
                    /* Error when opening reanalysis data file. */
                    setErrorMessage("\n    -> The reanalysis data file: "+reanalysisFiles.get(file)+" could not be opened.");
                    result=false;                    
                
                }

            }              
            
            /* Adds the matched database created.*/
            getMatchedDataBases().add(matchedDatabase);

        }else{

            /* Error when opening reanalysis data file. */
            setErrorMessage("\n    -> The reanalysis data file: "+reanalysisFiles.get(0)+" could not be opened.");
            result=false;
        
        }

        return result;
        
    }
    
    
        
    /**
     * Creates n' databases (one per each geopoint).
     * @return True if databases were properly created or False if the process failed.
     */
    private boolean createNDatabases(){
        
        /* Creates 'n' databases (one per each geopoint) */
        
        boolean result=true;
        
        /* Utilities. */
        Utils util = new Utils();
        
        /* Matched database to create. */                
        ArrayList<MatchingFinalDataset> matchedDatabases = new ArrayList<>();
                
        /* Reanalysis data files to use. */
        ArrayList<String> reanalysisFiles = getReanalysisFiles();
        
        /* Number of nearest geopoints to consider. */
        int numberOfNearestGeopointsToConsider = getNumberOfNearestGeopointsToConsider();
                
        /* Path to reanalysis files. */
        String path = System.getProperty("user.dir", ".")
              +File.separator+"DB"+File.separator+"reanalysisFiles"+File.separator;
        
        /* 
            Opens first reanalysis data file and gets:
                - number of instances
                - reanalysis dates
                - latitude size and data
                - longitude size and data
            This information is common to all reanalysis files received.
        */        

        /* Opens first reanalysis data file. */
        ReanalysisFile rf = new ReanalysisFile();

        if(rf.openFile(path+reanalysisFiles.get(0)) == true){
        
            /* Number of instances and reanalysis dates. */
            int numInstances=rf.getSizeVariable("time");
            ArrayDouble.D1 reanalysisDates = rf.getDataVariableTime();           

            /* Creates 'n' matched databases, one per each geopoint. */
            for (int n=0;n<numberOfNearestGeopointsToConsider && getPressedCancel()==false;n++){                
                
                /* One of 'n' matched databases. */
                MatchingFinalDataset oneMatchedDatabase = new MatchingFinalDataset();
                //oneMatchedDatabase.addAttribute("time");
                oneMatchedDatabase.addAttribute("DATE");

                /* Adds all values of variable time from reanalysis data file to each 'n' matched database. */
                for (int i=0;i<numInstances && getPressedCancel()==false;i++){                    

                    /* Creates the instance and sets time value. */
                    Instance instance=new Instance();

                        /* 
                            NetCDF establishes 1800-01-01 as date base, so it is necessary to 
                            convert to Unix seconds.
                        */

                        instance.addFieldValue(util.secondsFrom1800ToUnix(reanalysisDates.get(i)));

                    /* Adds the instance. */
                    oneMatchedDatabase.addInstance(instance);
                }
                
                /* Adds the matched database. */
                matchedDatabases.add(oneMatchedDatabase);
                
            }
            
            /* Latitude size and data. */
            int sizeLatitude=rf.getSizeVariable("lat");

            ArrayFloat.D1 latitudesAux = rf.getDataVariable("lat");
            double[] latitudesNorth=new double[sizeLatitude];

            for(int i=0;i<sizeLatitude;i++){

                /* NetCDF latitudes are in: Latitude North */
                latitudesNorth[i]=latitudesAux.get(i);

            }


            /* Longitude size and data. */
            int sizeLongitude=rf.getSizeVariable("lon");

            ArrayFloat.D1 longitudesAux = rf.getDataVariable("lon");
            double[] longitudesEast=new double[sizeLongitude];

            for(int i=0;i<sizeLongitude;i++){

                /* NetCDF longitudes are in: Longitude East */                
                longitudesEast[i]=longitudesAux.get(i);
                
            }

            /* Calculates weights depending on distance from buoy to each geopoint. */
            Double[][] weightsAndNearestGeopoints=calculateWeightsAndNearestGeopoints(latitudesNorth, longitudesEast, getBuoyLatitudeNorth(), getBuoyLongitudeEast(),numberOfNearestGeopointsToConsider);
            
            /* Closes file. */
            rf.closeFile();


            /*
                Opens each reanalysis file received and
                gets the data of the reanalysis variable that it contains.
            */
            
            for(int file=0;file<reanalysisFiles.size() && result == true && getPressedCancel()==false;file++){                

                /* Opens reanalysis data file. */
                rf = new ReanalysisFile();
                
                if(rf.openFile(path+reanalysisFiles.get(file))==true){

                    /* Adds reanalysis variable name to 'n' matched databases. */                                        
                    for(int i=0;i<matchedDatabases.size();i++){
                        
                        matchedDatabases.get(i).addAttribute(rf.getReanalysisVariableName());

                    }
                                        
                    /* Gets size and data. */
                    int sizeReanalysisVariable = rf.getReanalysisVariableSize();
                    ArrayFloat.D3 dataReanalysisVariable = rf.getReanalysisVariableData();
                
                    /* Sets reanalysis variable data to each instance of each matched database. */
                    for(int i=0;i<sizeReanalysisVariable && getPressedCancel()==false;i++){                    

                        /* Index of the matched database to process. */
                        int indexMatchedDatabase=0;
                        
                        /* Only nearest geopoints are considered. */
                        for(int k=0;k<numberOfNearestGeopointsToConsider;k++){
                            
                            /* Gets index of nearest geopoint. */
                            int indexGeopoint=weightsAndNearestGeopoints[k][0].intValue();
                            
                            /* Gets latitude and longitude index of nearest geopoint. */
                            int latitude=indexGeopoint / sizeLongitude;
                            int longitude=indexGeopoint % sizeLongitude;
                            
                            /* Sets value for reanalysis variable. */
                            matchedDatabases.get(indexMatchedDatabase).getInstance(i).addFieldValue(dataReanalysisVariable.get(i, latitude, longitude));
                            
                            /* Next matched database. */
                            indexMatchedDatabase++;
                            
                        }
                                                
                    }                
                
                    /* Closes file. */
                    rf.closeFile();

                }else{
                    
                    /* Error when opening reanalysis data file. */
                    setErrorMessage("\n    -> The reanalysis data file: "+reanalysisFiles.get(file)+" could not be opened.");
                    result=false;                    
                
                }

            }              
            
            /* Sets the 'n' matched databases created.*/
            setMatchedDataBases(matchedDatabases);

        }else{

            /* Error when opening reanalysis data file. */
            setErrorMessage("\n    -> The reanalysis data file: "+reanalysisFiles.get(0)+" could not be opened.");
            result=false;
        
        }

        return result;
        
    }
    
    
    
    /**
     * Matches databases's intances previously created with dataset file's information.
     * @return True if instances were properly matched or False if the process failed.
     */
    private boolean matchingInstances(){
    
        boolean result=true;
        
        /* Number of the instances matched. */
        int numberOfInstancesMatched = 0;
        
        /* Max interval (in seconds) between dates for considering a missing date or not. */
            /* 3600 seconds -> 60 minutes. */
        //long intervalBetweenDates=900;
        long intervalBetweenDates=3600;

        /* Matched databases already created. */                
        ArrayList<MatchingFinalDataset> matchedDatabases = getMatchedDataBases();
        
        /* Root. */
        String root = System.getProperty("user.dir", ".")+File.separator+"DB"+File.separator;
        
        /* Gets the name of the XML file. */
        String xmlFilename = root+getDatasetFilePath().substring(0, getDatasetFilePath().length() - 3) + ".xml";
                        
        /* Reads the xml file. */
        File xml = new File(xmlFilename);
                       
        if(xml.exists()){
            
            /* Gets XML file with the information about dataset file received. */
            XMLFile<DatasetInformation> xmlFile = new XMLFile<>(DatasetInformation.class, xml);

            /* Loads information about the dataset file. */
            DatasetInformation datasetInfo = xmlFile.readXMLFile();
            
            if(datasetInfo!=null){

                /* 
                    Number of attributes that a matched database will have:
                        -> TIME
                        -> attribute to predict of dataset file
                        -> one reanalysis variable per file                        
                        -> remaining attributes of dataset (depending on user selection)
                . */
                int numAttributesInMatchedDatabase = 2 + getReanalysisFiles().size();
                
                /* Dataset file to load. */
                DatasetFile fileDataset = new DatasetFile();

                fileDataset.setFileName(root+getDatasetFilePath());

                /* Loads dataset file information in memory to work with. */
                if (fileDataset.readFile(getDatasetFileType(), datasetInfo.getHeaderDatasetFile()) == true){
                    
                    /* Checks if flux of energy has to be calculated. */
                    if(getCalculateFluxOfEnergy()==true){
                        
                        /* Calculates flux of energy. */
                        calculateFluxOfEnergy(fileDataset);
                    
                    }
                    
                    /* Indexes of the selected variables of the buoy to include. */
                    ArrayList<Integer> buoyVariablesIndexes = new ArrayList<>();
                    
                    /* Index of the attribute to predict. */
                    int indexAttributeToPredict = fileDataset.indexOfAttribute(getAttributeNameToPredict());
                    
                    /* Checks is user selected include attributes as inputs. */
                    //if (getIncludeAttributesAsInputs()==true){
                    if (getBuoyVariables().isEmpty()==false){
                        
                        /* Adds attributes NAMES of dataset file to matched databases already created. */
                        
                        /* Indexes of the selected variables of the buoy to include. */
                        //ArrayList<Integer> buoyVariablesIndexes = new ArrayList<>();
                        
                        /* Gets the indexes. */
                        for(String variable : getBuoyVariables()) {
                            
                            /* Adds the index. */
                            buoyVariablesIndexes.add(fileDataset.getAttributes().indexOf(variable));
                            
                        }

                        /* 
                            i=0 -> DATE attribute is not added, it is only used for matching with TIME
                                   attribute from reanalysis data files, already added in matched databases.
                        */                    
                        //for(int indexAttribute=1;indexAttribute<fileDataset.numAttributes(); indexAttribute++) {
                        for(int indexAttribute : buoyVariablesIndexes) {
                            for (MatchingFinalDataset oneMatchedDatabase : matchedDatabases) {

                                /* Attribute to predict will be the last one in matched databases. */
                                //if (indexAttribute!=indexAttributeToPredict) {

                                    /* Adds one remaining attribute. */
                                    //oneMatchedDatabase.addAttribute(fileDataset.getAttribute(indexAttribute));
                                    
                                    /* Adds one selected attribute. */
                                    oneMatchedDatabase.addAttribute(fileDataset.getAttribute(indexAttribute));
                                    
                                //}
                            }
                        } 
                        
                        /* Adds number of attributes in dataset: -2
                            -> TIME previously added
                            -> Attribute to predict previously added
                        */
                        //numAttributesInMatchedDatabase = numAttributesInMatchedDatabase + ( fileDataset.numAttributes() - 2);
                        numAttributesInMatchedDatabase = numAttributesInMatchedDatabase + ( getBuoyVariables().size() );
                    
                    }                                        
                    
                    /* Attribute to predict is always the last one in matched databases. */
                    for (MatchingFinalDataset oneMatchedDatabase : matchedDatabases) {
                        oneMatchedDatabase.addAttribute(getAttributeNameToPredict());
                    }                                        
                                        
                    
                    /* 
                        Matches instances from dataset file with reanalysis files data.
                    
                        One instance matches when the difference between TIME (reanalysis files data)
                        and DATE (dataset) is less or equal than a specific interval of seconds.
                    
                    */                                        
                    
                    /* To start searching from last instance found. */
                    int lastInstanceMatched=0;    
                    
                    /* Index of the closest instance found or current one if not. */
                    //int indexOfClosestInstanceDatasetFound = 0;
                    
//                    for(int numInstanceDataset=0;numInstanceDataset<fileDataset.numInstances() && getPressedCancel()==false;numInstanceDataset++){

                    /* Index of the instance to process. */
                    int numInstanceDataset=0;
                    
                    /* Checks if there is one instance at least to check. */
                    if(numInstanceDataset<fileDataset.numInstances()){
                        
                        do{
                        
//                        /* */
//                        if(indexOfClosestInstanceDatasetFound==numInstanceDataset){

                            MatchingFinalDataset firstMatchedDatabase = matchedDatabases.get(0);
                                                
//                            for (MatchingFinalDataset oneMatchedDatabase : matchedDatabases) {

                                /* To know if an instance is matched. */
                                boolean instanceMatched=false;

                                /* Starts from last instance matched. */
                                for(int numInstanceMatchedDatabase=lastInstanceMatched;numInstanceMatchedDatabase<firstMatchedDatabase.numInstances() && instanceMatched==false && getPressedCancel()==false;numInstanceMatchedDatabase++){

                                    /* 
                                        Gets both dates:
                                          attribute TIME (reanalysis file date) already stored in matched databases.
                                          attribute DATE (dataset)                                
                                    */

                                    /* Attribute TIME (reanalysis file date) */
                                    Date date1 = new Date();
                                    date1.setTime(firstMatchedDatabase.getInstance(numInstanceMatchedDatabase).getFieldValue(0).longValue() * 1000);

                                    /* Attribute DATE (dataset) */
                                    Date date2 = new Date();
                                    date2.setTime(fileDataset.getInstance(numInstanceDataset).getFieldValue(0).longValue() * 1000);

                                    /* Gets the difference.*/
                                    long difference1=Math.abs((date1.getTime()-date2.getTime())/1000);
                                    
                                    /* 
                                        One instance matches when the difference between TIME (reanalysis files data)
                                        and DATE (dataset) is less or equal than a specific interval of seconds.
                                    */

                                    if(difference1<=intervalBetweenDates){
                                        
                                        /* To set buoys variables in matched final datasets and process next instance. */
                                        instanceMatched = true;
                                        
                                        /* A new instances has been matched. */
                                        numberOfInstancesMatched=numberOfInstancesMatched+1;
                                        
                                        /* To start searching from last instance found. */
                                        lastInstanceMatched=numInstanceMatchedDatabase;

                                        /* Checks if there is a closest instance. */

                                        /* Gets the next instance to check. */
                                        int nextInstanceDataset = numInstanceDataset+1;

                                        /* Checks if there is another instance at least. */
                                        if(nextInstanceDataset<fileDataset.numInstances()){

                                            /* To store the new difference. */
                                            long difference2;

                                            /* Search for a closest instance. */
                                            do{

                                                /* Attribute DATE (dataset) */
                                                date2.setTime(fileDataset.getInstance(nextInstanceDataset).getFieldValue(0).longValue() * 1000);

                                                /* Gets the new difference.*/
                                                difference2=Math.abs((date1.getTime()-date2.getTime())/1000);

                                                /* Checks if it is a closest date. */
                                                if(difference2 <= difference1){
                                                    
                                                    /* Closest instance found. */                                                   
                                                    numInstanceDataset=nextInstanceDataset;
                                                    
                                                    /* Sets current difference for the next closest isntance. */
                                                    difference1 = difference2;

                                                }

                                                /* Checks next instance. */
                                                nextInstanceDataset=nextInstanceDataset+1;

                                            }while(nextInstanceDataset<fileDataset.numInstances() && (difference2 <= difference1) && getPressedCancel()==false);

                                        }
                                    }
                                }
                                
                                /* Checks if an instance was matched. */
                                if(instanceMatched == true){
                                    
                                    /* Instance matched. */
                                    
                                    /* Sets buoys variables in matched final datasets. */
                                    for (MatchingFinalDataset oneMatchedDatabase : matchedDatabases) {

                                        /* Checks is user selected include attributes as inputs. */
                                        //if (getIncludeAttributesAsInputs()==true){
                                        if (getBuoyVariables().isEmpty()==false){

                                            /* Adds attributes VALUES of dataset file to matched databases already created. */

                                            /* 
                                                i=0 -> DATE attribute is not added, it is only used for matching with TIME
                                                       attribute from reanalysis data files, already stored in matched databases.
                                            */                    
                                            //for(int indexAttribute=1;indexAttribute<fileDataset.numAttributes(); indexAttribute++) {
                                            for(int indexAttribute : buoyVariablesIndexes) {
                                            

                                                /* Attribute to predict is always the last one in matched databases. */
                                                //if (indexAttribute!=indexAttributeToPredict) {

                                                    /* Adds one remaining attribute value. */
                                                    //oneMatchedDatabase.getInstance(lastInstanceMatched).addFieldValue(fileDataset.getInstance(numInstanceDataset).getFieldValue(indexAttribute).doubleValue());
                                                    
                                                    /* Adds one selected attribute value. */
                                                    oneMatchedDatabase.getInstance(lastInstanceMatched).addFieldValue(fileDataset.getInstance(numInstanceDataset).getFieldValue(indexAttribute).doubleValue());
                                                //}

                                            }

                                        }

                                        /* Attribute to predict is always the last one in matched databases. */
                                        oneMatchedDatabase.getInstance(lastInstanceMatched).addFieldValue(fileDataset.getInstance(numInstanceDataset).getFieldValue(indexAttributeToPredict).doubleValue());
                                
                                    }

                                    /* To start searching from last instance found. */
                                    lastInstanceMatched = lastInstanceMatched +1;
                                
                                }
                                
                                /* To process next instance. */
                                numInstanceDataset=numInstanceDataset+1;
                                
                        }while(numInstanceDataset<fileDataset.numInstances() && getPressedCancel()==false);
                        
                    }
                    
                    /* Sets the number of instances matched. */
                    setNumOfInstancesMatched(numberOfInstancesMatched);

                    /* 
                        Sets missing dates found in matching:
                            all matched databases have the same missing dates, that's
                            why is only necessary to process one matched database.
                    */
                    setMissingDates(getMissingDatesMatching(matchedDatabases.get(0), numAttributesInMatchedDatabase));

                    
                    /* Checks if missing dates have to be included or not. */
                    if (getIncludeMissingDates()==false){
                        
                        /* Deletes all missing dates from all instances of every matched database created. */
                        deleteMissingDatesFromMatchedDatabases(matchedDatabases);
                    
                    }
                    
                }else{
                    
                    /* Error when reading dataset file received. */
                    setErrorMessage("\n    -> The selected dataset: "+root+getDatasetFilePath()+" could not be readed.");
                    result=false;
                }                
            }else{
                
                /* Error when reading XML of dataset file received. */
                setErrorMessage("\n    -> The file: "+xmlFilename+" could not be readed.");
                result=false;
            }
        }else{

            /* Error when opening XML of dataset file received. */
            setErrorMessage("\n    -> The file: "+xmlFilename+" could not be opened.");
            result=false;
        }
        
        return result;
    
    }
    
   
    
//    /**
//     * Matches databases's intances previously created with dataset file's information.
//     * @return True if instances were properly matched or False if the process failed.
//     */
//    private boolean ok_matchingInstances(){
//    
//        boolean result=true;
//        
//        /* Max interval (in seconds) between dates for considering a missing date or not. */
//            /* 1800 seconds -> 30 minutes. */
//        //long intervalBetweenDates=1800;
//        long intervalBetweenDates=900;
//               
//        /* Matched databases already created. */                
//        ArrayList<MatchingFinalDataset> matchedDatabases = getMatchedDataBases();
//        
//        /* Root. */
//        String root = System.getProperty("user.dir", ".")+File.separator+"DB"+File.separator;
//        
//        /* Gets the name of the XML file. */
//        String xmlFilename = root+getDatasetFilePath().substring(0, getDatasetFilePath().length() - 3) + ".xml";
//                        
//        /* Reads the xml file. */
//        File xml = new File(xmlFilename);
//                       
//        if(xml.exists()){
//            
//            /* Gets XML file with the information about dataset file received. */
//            XMLFile<DatasetInformation> xmlFile = new XMLFile<>(DatasetInformation.class, xml);
//
//            /* Loads information about the dataset file. */
//            DatasetInformation datasetInfo = xmlFile.readXMLFile();
//            
//            if(datasetInfo!=null){
//
//                /* 
//                    Number of attributes that a matched database will have:
//                        -> TIME
//                        -> attribute to predict of dataset file
//                        -> one reanalysis variable per file                        
//                        -> remaining attributes of dataset (depending on user selection)
//                . */
//                int numAttributesInMatchedDatabase = 2 + getReanalysisFiles().size();
//                
//                /* Dataset file to load. */
//                DatasetFile fileDataset = new DatasetFile();
//
//                fileDataset.setFileName(root+getDatasetFilePath());
//
//                /* Loads dataset file information in memory to work with. */
//                if (fileDataset.readFile(getDatasetFileType(), datasetInfo.getHeaderDatasetFile()) == true){
//                    
//                    /* Checks if flux of energy has to be calculated. */
//                    if(getCalculateFluxOfEnergy()==true){
//                        
//                        /* Calculates flux of energy. */
//                        calculateFluxOfEnergy(fileDataset);
//                    
//                    }
//                    
//                    
//                    /* Index of the attribute to predict. */
//                    int indexAttributeToPredict = fileDataset.indexOfAttribute(getAttributeNameToPredict());
//
//                    /* Checks is user selected include attributes as inputs. */
//                    if (getIncludeAttributesAsInputs()==true){
//                    
//                        /* Adds attributes NAMES of dataset file to matched databases already created. */
//
//                        /* 
//                            i=0 -> DATE attribute is not added, it is only used for matching with TIME
//                                   attribute from reanalysis data files, already added in matched databases.
//                        */                    
//                        for(int indexAttribute=1;indexAttribute<fileDataset.numAttributes(); indexAttribute++) {
//                            for (MatchingFinalDataset oneMatchedDatabase : matchedDatabases) {
//
//                                /* Attribute to predict will be the last one in matched databases. */
//                                if (indexAttribute!=indexAttributeToPredict) {
//
//                                    /* Adds one remaining attribute. */
//                                    oneMatchedDatabase.addAttribute(fileDataset.getAttribute(indexAttribute));
//                                    
//                                }
//                            }
//                        } 
//                        
//                        /* Adds number of attributes in dataset: -2
//                            -> TIME previously added
//                            -> Attribute to predict previously added
//                        */
//                        numAttributesInMatchedDatabase = numAttributesInMatchedDatabase + ( fileDataset.numAttributes() - 2);
//                    
//                    }                                        
//                    
//                    /* Attribute to predict is always the last one in matched databases. */
//                    for (MatchingFinalDataset oneMatchedDatabase : matchedDatabases) {
//                        oneMatchedDatabase.addAttribute(getAttributeNameToPredict());
//                    }                                        
//                                        
//                    
//                    /* 
//                        Matches instances from dataset file with reanalysis files data.
//                    
//                        One instance matches when the difference between TIME (reanalysis files data)
//                        and DATE (dataset) is less or equal than a specific interval of seconds.
//                    
//                    */                                        
//                    
//                    /* To start searching from last instance found. */
//                    int lastInstanceMatched=0;                    
//                    
//                    for(int numInstanceDataset=0;numInstanceDataset<fileDataset.numInstances() && getPressedCancel()==false;numInstanceDataset++){
//                        
//                        for (MatchingFinalDataset oneMatchedDatabase : matchedDatabases) {
//                            
//                            /* To know if an instance is matched. */
//                            boolean instanceMatched=false;
//
//                            /* Starts from last intance matched. */
//                            for(int numInstanceMatchedDatabase=lastInstanceMatched;numInstanceMatchedDatabase<oneMatchedDatabase.numInstances() && instanceMatched==false && getPressedCancel()==false;numInstanceMatchedDatabase++){
//
//                                /* 
//                                    Gets both dates:
//                                      attribute TIME (reanalysis file date) already stored in matched databases.
//                                      attribute DATE (dataset)                                
//                                */
//                                                                
//                                /* Attribute TIME (reanalysis file date) */
//                                Date date1 = new Date();
//                                date1.setTime(oneMatchedDatabase.getInstance(numInstanceMatchedDatabase).getFieldValue(0).longValue() * 1000);
//                                
//                                /* Attribute DATE (dataset) */
//                                Date date2 = new Date();
//                                date2.setTime(fileDataset.getInstance(numInstanceDataset).getFieldValue(0).longValue() * 1000);
//
//                                /* Gets the difference.*/
//                                long difference=Math.abs((date1.getTime()-date2.getTime())/1000);
//                                
//                                /* 
//                                    One instance matches when the difference between TIME (reanalysis files data)
//                                    and DATE (dataset) is less or equal than a specific interval of seconds.
//                                */
//                                
//                                //if(difference<=900){
//                                if(difference<=intervalBetweenDates){
//
//                                    /* Instance matched. */
//                                    
//                                    /* Checks is user selected include attributes as inputs. */
//                                    if (getIncludeAttributesAsInputs()==true){
//                                        
//                                        /* Adds attributes VALUES of dataset file to matched databases already created. */
//
//                                        /* 
//                                            i=0 -> DATE attribute is not added, it is only used for matching with TIME
//                                                   attribute from reanalysis data files, already stored in matched databases.
//                                        */                    
//                                        for(int indexAttribute=1;indexAttribute<fileDataset.numAttributes(); indexAttribute++) {
//
//                                            /* Attribute to predict is always the last one in matched databases. */
//                                            if (indexAttribute!=indexAttributeToPredict) {
//
//                                                /* Adds one remaining attribute value. */
//                                                oneMatchedDatabase.getInstance(numInstanceMatchedDatabase).addFieldValue(fileDataset.getInstance(numInstanceDataset).getFieldValue(indexAttribute).doubleValue());
//                                            }
//
//                                        }
//                                                                                
//                                    }
//                                    
//                                    /* Attribute to predict is always the last one in matched databases. */
//                                    oneMatchedDatabase.getInstance(numInstanceMatchedDatabase).addFieldValue(fileDataset.getInstance(numInstanceDataset).getFieldValue(indexAttributeToPredict).doubleValue());
//                                                                                
//                                    /* To process next instance. */
//                                    instanceMatched = true;
//                                    
//                                    /* To start searching from last instance found. */
//                                    lastInstanceMatched=numInstanceMatchedDatabase;
//                                    
//                                }                                
//                            }
//                        }
//                    }
//                    
//
//                    /* 
//                        Sets missing dates found in matching:
//                            all matched databases have the same missing dates, that's
//                            why is only necessary to process one matched database.
//                    */
//                    setMissingDates(getMissingDatesMatching(matchedDatabases.get(0), numAttributesInMatchedDatabase));
//
//                    
//                    /* Checks if missing dates have to be included or not. */
//                    if (getIncludeMissingDates()==false){
//                        
//                        /* Deletes all missing dates from all instances of every matched database created. */
//                        deleteMissingDatesFromMatchedDatabases(matchedDatabases);
//                    
//                    }
//                    
//                }else{
//                    
//                    /* Error when reading dataset file received. */
//                    setErrorMessage("\n    -> The selected dataset: "+root+getDatasetFilePath()+" could not be readed.");
//                    result=false;
//                }                
//            }else{
//                
//                /* Error when reading XML of dataset file received. */
//                setErrorMessage("\n    -> The file: "+xmlFilename+" could not be readed.");
//                result=false;
//            }
//        }else{
//
//            /* Error when opening XML of dataset file received. */
//            setErrorMessage("\n    -> The file: "+xmlFilename+" could not be opened.");
//            result=false;
//        }
//        
//        return result;
//    
//    }
    


    /**
     * Calculates nearest geopoints and weights depending on distance between buoy and each 
     * geopoint (latitude,longitude) in reanalysis data file, nearest geopoints
     * to the buoy will have the highest weights (more importance) and vice versa.
     * @param latitudesNorth Array with latitude of each geopoint.
     * @param longitudesEast Array with longitude of each geopoint.
     * @param buoyLatitudeNorth Latitude North of the buoy.
     * @param buoyLongitudeEast Longitude East of the buoy.
     * @param numGeopoints Number of geopoints to considerer.
     * @return Two dimensional array with indexes of nearest geopoints and weights depending on distance.
     */    
    private static Double[][] calculateWeightsAndNearestGeopoints(double[] latitudesNorth, double[] longitudesEast, double buoyLatitudeNorth, double buoyLongitudeEast, int numGeopoints){        
                
        /* Index and distance of each geopoint. */
        Double[][] geopointsAndDistances = new Double[latitudesNorth.length*longitudesEast.length][2];
        
        /* Index and weight of each nearest geopoint to consider. */
        Double[][] nearestGeopointsAndWeights=new Double[numGeopoints][2];
                
        /* Total distances of nearest geopoints to consider. */
        Double sumDistancesNearestGeopoints=0.0;
        
        /* Index of each geopoint. */
        int geopointIndex=0;

        
        /* Calculates distances. */                
        for(int i=0;i<latitudesNorth.length;i++){
            for(int j=0;j<longitudesEast.length;j++){        
                
                /* Index of geopoint (+0.0  -> Converts to Double ). */
                geopointsAndDistances[geopointIndex][0]=geopointIndex+0.0;
                
                /* Distance of geopoint. */
                geopointsAndDistances[geopointIndex][1]=distanceBetween2Geopoints(buoyLatitudeNorth,buoyLongitudeEast,latitudesNorth[i],longitudesEast[j]);
                
                /* Next geopoint. */
                geopointIndex++;
                
            }
        }
            
        /* Checks if any distance is 0.0 */
        for(int i=0;i<geopointsAndDistances.length;i++){
            
            if(geopointsAndDistances[i][1]==0.0){
                
                /* To avoid divide by 0.0 */
                geopointsAndDistances[i][1]=0.0000001;
                
            }
            
        }
        

        /* Sorts distances in ascending order. */ 
        
        Arrays.sort(geopointsAndDistances, new Comparator<Double[]>() {
            
            @Override
            public int compare(Double[] distance1, Double[] distance2) {
                
                if (distance1[1] > distance2[1]){
                    
                    return 1;
                
                }else if (distance1[1] < distance2[1]){
                    
                    return -1;
                    
                }else {
                    
                    /* Both distances are equals. */
                    return 0;
                }
            }

        });
        
                
        /* Gets only nearest geopoints. */
        for(int i=0;i<numGeopoints;i++){
            
            /* Gets index of nearest geopoint. */
            nearestGeopointsAndWeights[i][0]=geopointsAndDistances[i][0];
            
            /* Gets distance of nearest geopoint. */
            nearestGeopointsAndWeights[i][1]=geopointsAndDistances[i][1];
        
        }

        
        /* Calculates total distances of nearest geopoints. */
        for(int i=0;i<numGeopoints;i++)
                sumDistancesNearestGeopoints+=1./nearestGeopointsAndWeights[i][1];
        
        
        /* Calculates weights depending on distance of nearest geopoints. */                
        for(int i=0;i<numGeopoints;i++)        
                nearestGeopointsAndWeights[i][1]=(1./nearestGeopointsAndWeights[i][1])/(sumDistancesNearestGeopoints);

                        
        return nearestGeopointsAndWeights;
        
    }


    
    /** 
     * Calculates distance in kilometers between two geopoints.
     * @param lat1 Latitude of geopoint 1
     * @param lng1 Longitude of geopoint 1
     * @param lat2 Latitude of geopoint 2
     * @param lng2 Longitude of geopoint 2
     * @return Distance between geopoint 1 and geopoint 2
     */
    private static double distanceBetween2Geopoints(double lat1, double lng1, double lat2, double lng2) {  
        
        /* Calculates distance in kilometers between geopoints received. */
        
        //double earthRadius = 3958.75; //miles
        double earthRadius = 6371; //kilometers  
        double dLat = Math.toRadians(lat2 - lat1);  
        double dLng = Math.toRadians(lng2 - lng1);  
        double sindLat = Math.sin(dLat / 2);  
        double sindLng = Math.sin(dLng / 2);  
        double a = Math.pow(sindLat, 2) + Math.pow(sindLng, 2)  
                * Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2));  
        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));  
        double dist = earthRadius * c;  
  
        return dist;  
    }
    
    
        
    /**
     * Gets missing dates from first matched databases (all matched databases have the same missing dates).
     * @param firstMatchedDatabase First matched database created.
     * @param numAttributesInMatchedDatabase Number of attributes in matched database.
     * @return Missing dates found.
     */
    private ArrayList<String> getMissingDatesMatching(MatchingFinalDataset firstMatchedDatabase, int numAttributesInMatchedDatabase){
                    
        /* 
            Gets missing dates from first matched databases.
                (all matched databases have the same missing dates)
        */


        /* Missing dates found. */
        ArrayList<String> missingDatesFound = new ArrayList<>();
        
        /* Gets indexes of instances that are missing dates. */
        ArrayList<Integer> indexMissingInstancesFound = getIndexMissingInstances();

        /* Utilities. */
        Utils util = new Utils();

        /*
            Gets missing dates:
                instances that have a different number of attributes
                than expected ->  numAttributesInMatchedDatabase
        */

        /* Checks each instance in matched database. */
        for(int numInstanceMatchedDatabase=0;numInstanceMatchedDatabase<firstMatchedDatabase.numInstances() && getPressedCancel()==false;numInstanceMatchedDatabase++){
            
            if (firstMatchedDatabase.getInstance(numInstanceMatchedDatabase).numFieldsValues()!=numAttributesInMatchedDatabase){                                                

                /* Missing date. */
                
                /* Gets date in time stamp format. */
                missingDatesFound.add(util.unixSecondsToTimeStamp(firstMatchedDatabase.getInstance(numInstanceMatchedDatabase).getFieldValue(0).longValue()));
                
                /* Adds instance index. */
                indexMissingInstancesFound.add(numInstanceMatchedDatabase);
                
            }

        }
        
        return missingDatesFound;
    }



    /**
     * Deletes missing dates found from all instances of every matched database created.
     * @param matchedDatabases Matched databases created.
     */
    private void deleteMissingDatesFromMatchedDatabases(ArrayList<MatchingFinalDataset> matchedDatabases){

        /* Deletes missing dates found from all instances of every matched database created. */
        
        /* Gets indexes of instances that are missing dates. */
        ArrayList<Integer> indexMissingInstancesFound = getIndexMissingInstances();

        /* Number of instances deleted in each matched database. */
        int instancesDeleted;
                
        /* Checks all matched databases. */
        for (MatchingFinalDataset oneMatchedDatabase : matchedDatabases) {
            
            /* Number of instances deleted in each matched database. */
            instancesDeleted=0;

            /* Deletes all instances that are missing dates. */
            for(Integer index: indexMissingInstancesFound){

                /* Deletes instance. */
                oneMatchedDatabase.delInstance(index-instancesDeleted);
                
                /* One more instance deleted. */
                instancesDeleted++;

            }
        }
    }
    
    
    
    /**
     * Calculates flux of energy.
     * @param fileDataset Dataset file selected for matching process.
     */
    private void calculateFluxOfEnergy(DatasetFile fileDataset){
                        
        /* Number of instances. */
        int numInstances=fileDataset.numInstances();

        /* Missing value of WVHT. */
        double missingWVHT=fileDataset.getValueOfMissingValue("WVHT");
        
        /* Index of WVHT attribute. */
        int indexWVHT=fileDataset.getAttributes().indexOf("WVHT");
                
        /* Missing value of APD. */
        double missingAPD=fileDataset.getValueOfMissingValue("APD");
        
        /* Index of APD attribute. */
        int indexAPD=fileDataset.getAttributes().indexOf("APD");
        
        /* Defines missing value for FLUXOFENERGY. */
        double missingFluxOfEnergy=99999;
        
        /* Flux of energy. */
        double valueFluxOfEnergy;

        /* APD. */
        double valueAPD;

        /* WVHT. */
        double valueWVHT;

        
        /* Adds attribute flux of energy. */
        fileDataset.addAttribute(getAttributeNameToPredict());

        
        /* Calculates flux of energy of each instance. */
        for(int i=0;i<numInstances;i++){
            
            /* Gets value of APD. */
            valueAPD=fileDataset.getInstance(i).getFieldValue(indexAPD).doubleValue();

            /* Gets value of WVHT. */
            valueWVHT=fileDataset.getInstance(i).getFieldValue(indexWVHT).doubleValue();
            
            /* Checks if WVHT or APD attributes are missing values. */
            if(valueAPD==missingAPD || valueWVHT==missingWVHT){
                
                /* Sets flux of energy as missing value. */
                valueFluxOfEnergy=missingFluxOfEnergy;
            
            }else{
                
                /* Calculates flux of energy. */
                valueFluxOfEnergy=( 0.49 * (valueWVHT * valueWVHT) * valueAPD );
            
            }
            
            /* Adds flux of energy. */
            fileDataset.getInstance(i).addFieldValue(valueFluxOfEnergy);
        
        }

    }


    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        btnOK = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        jtaStatusSummary = new javax.swing.JTextArea();
        lblStatus = new javax.swing.JLabel();
        btnCancel = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
        setTitle("SPAMDA 1.0-Running matching process");
        setResizable(false);

        btnOK.setText("OK");
        btnOK.setEnabled(false);
        btnOK.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnOKActionPerformed(evt);
            }
        });

        jtaStatusSummary.setColumns(20);
        jtaStatusSummary.setRows(5);
        jtaStatusSummary.setName(""); // NOI18N
        jScrollPane1.setViewportView(jtaStatusSummary);

        lblStatus.setText("Status:");

        btnCancel.setText("Cancel matching");
        btnCancel.setToolTipText("Cancel matching process");
        btnCancel.setEnabled(false);
        btnCancel.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCancelActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(lblStatus)
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 422, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(64, 64, 64)
                        .addComponent(btnCancel, javax.swing.GroupLayout.PREFERRED_SIZE, 154, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(55, 55, 55)
                        .addComponent(btnOK, javax.swing.GroupLayout.PREFERRED_SIZE, 103, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(lblStatus)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 260, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnOK)
                    .addComponent(btnCancel))
                .addContainerGap())
        );

        pack();
        setLocationRelativeTo(null);
    }// </editor-fold>//GEN-END:initComponents

    private void btnOKActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnOKActionPerformed

        /* Closes the JDialog. */
        this.dispose();
        
    }//GEN-LAST:event_btnOKActionPerformed

    private void btnCancelActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCancelActionPerformed
        
        /* Disables Cancel button. */
        btnCancel.setEnabled(false);
        
        /* To know that user pressed Cancel button. */
        setPressedCancel();

        /* Cancels the process. */        
        worker.cancel(true);

    }//GEN-LAST:event_btnCancelActionPerformed
    

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnCancel;
    private javax.swing.JButton btnOK;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextArea jtaStatusSummary;
    private javax.swing.JLabel lblStatus;
    // End of variables declaration//GEN-END:variables
}
