/*
SPAMDA: Software for Pre-processing and Analysis of Meteorological DAta to build datasets

Copyright (c) 2017-2021 by AYRNA Research Group. https://www.uco.es/ayrna/
    Authors: 
      Gómez-Orellana, A.M.; Fernández, J.C.; Dorado-Moreno, M.; Gutiérrez, P.A.; Hervás-Martínez, C.
      Building Suitable Datasets for Soft Computing and Machine Learning Techniques from Meteorological
       Data Integration: A Case Study for Predicting Significant Wave Height and Energy Flux.
      Energies 2021, 14, 468. https://doi.org/10.3390/en14020468                                                                       

This program is free software: you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software Foundation,
either version 3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program,
in the file COPYING. If not, see <http://www.gnu.org/licenses/>.

Additional permissions under GNU GPL version 3 section 7:
1. Redistributions of source code, with or without modification, must retain
the above full copyright notice as author attributions.

2. Redistributions in binary form and/or the use of the documentation,
with or without modification, must reproduce the above full copyright notice
as author attributions in the documentation and/or materials provided with
the distribution.

3. Modified versions of source code and/or documentation, as well as binary
distributions, must be marked in reasonable ways as different from the original version.

4. Neither name of copyright holders nor the names of its contributors may be used
to endorse or promote products derived from this software for publicity purposes
without specific prior written permission.

5. Redistribution and/or use of source code, binary format and documentation,
with or without modification, could require indemnification of licensors
and authors by anyone who conveys the material (or modified versions of it)
with contractual assumptions of liability to the recipient, for any liability
that these contractual assumptions directly impose on those licensors and authors.

SPAMDA uses some external libraries. You can see their respective notices about license,
copyright and disclaimer in the following files. For a more complete information about
such licenses, see the distributions provided by their authors:
-Library NetCDF Java, version 4.6.10
	Notice of license in the file NetCDF-LICENSE
-Library SLF4J, version 1.7.25
	Notice of license in the file SLF4J-LICENSE
-Library WEKA, version 3.8.1
	Notice of license in the file WEKA-LICENSE

Contact information:
Antonio Manuel Gomez Orellana, Mr.
email: am[dot]gomez[at]uco[dot]es
Address: University of Cordoba, Department of Computer Science
and Numerical Analysis, AYRNA Research Group, Rabanales Campus,
Einstein Building, 3rd floor. Road Madrid-Cadiz, Km 396-A.
14071 - Cordoba (Spain).

Juan Carlos Fernandez Caballero, PhD.
email: jfcaballero[at]uco[dot]es
Address: University of Cordoba, Department of Computer Science
and Numerical Analysis, AYRNA Research Group, Rabanales Campus,
Einstein Building, 3rd floor. Road Madrid-Cadiz, Km 396-A.
14071 - Cordoba (Spain).
 */

package view;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.TimeZone;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.SwingWorker;
import utils.Utils;
import xml.DatasetInformation;
import xml.XMLFile;


/**
 * This class defines the view to start the process of creation of an intermediate dataset file.
 * 
 * The status of the process is showed and it can be cancelled by the user.
 * 
 */
public class RunCreationDataset extends javax.swing.JDialog {
        
    /* Generated by NetBeans. */
    private static final long serialVersionUID = -7721443095632647879L;
    
    
    /**
     * Dataset file's name to create.
     */
    private File datasetFileName;
    
    
    /**
     * XML file's name to create.
     */
    private File xmlFileName;
    
    
    /**
     * Short description of the dataset file to create.
     */
    private String shortDescription;
    
    
    /**
     * Files to merge in dataset file.
     */
    private ArrayList<File> files;

    
    /**
     * Instances merged in dataset file.
     */
    private ArrayList<String> instances;
    
    
    /**
     * The SwingWorker.
     */
    private SwingWorker<Void, String> worker;

    
    /**
     * To check if user pressed 'Cancel' button.
     */    
    private boolean cancelPressed;
    
    
    /**
     * Creates new dialog RunCreationDataset
     * @param parent Jframe that creates this dialog.
     * @param modal Indicates if the dialog is modal or not.
     */
    public RunCreationDataset(java.awt.Frame parent, boolean modal) {
        
        super(parent, modal);
        initComponents();
        
        /* Initializes to default values. */
        
        this.files=new ArrayList<>();
        this.datasetFileName=null;
        this.xmlFileName=null;
        this.shortDescription=null;
        this.instances=new ArrayList<>();
        this.cancelPressed=false;
        
    }
    

    /* Methods of the class */

    
    /**
     * Returns dataset file's name to create.
     * @return Dataset file's name to create.
     */
    private File getDatasetFilename(){
    
        /* Gets dataset file name to create. */
        
        return datasetFileName;

    }
    
    
    /**
     * Sets dataset file's name to create.
     * @param datasetFileName Dataset file's name to create.
     */
    public void setDatasetFilename(File datasetFileName){
    
        /* Sets dataset file name to create. */
        
        this.datasetFileName = datasetFileName;

    }


    /**
     * Returns XML file's name to create.
     * @return XML file's name to create.
     */
    private File getXMLFilename(){
    
        /* Gets XML file name to create. */
        
        return xmlFileName;

    }
    
    
    /**
     * Sets XML file's name to create.
     * @param xmlFilename XML file's name to create.
     */
    public void setXMLFilename(File xmlFilename){
    
        /* Sets XML file name to create. */
        
        this.xmlFileName = xmlFilename;

    }

   
    /**
     * Sets short description of the dataset file to create.
     * @param shortDescription Short description of the dataset file to create.
     */
    public void setShortDescription(String shortDescription){
    
        /* Sets short description of the dataset file to create. */
        
        this.shortDescription = shortDescription;

    }

    
    /**
     * Returns files to merge in dataset file.
     * @return Files to merge in dataset file.
     */
    private ArrayList<File> getFiles(){
    
        /* Gets files to merge. */
        
        return files;

    }
    
    
    /**
     * Sets files to merge in dataset file.
     * @param files Files to merge in dataset file.
     */
    public void setFiles(ArrayList<File> files){
    
        /* Sets files to merge. */
        
        this.files = files;

    }


    /**
     * Returns instances merged in dataset file.
     * @return Instances merged in dataset file.
     */
    private ArrayList<String> getInstances(){
    
        /* Gets instances merged. */
        
        return instances;

    }

    
    /**
     * Sets True that user pressed 'Cancel' button.
     */
    private void setPressedCancel(){
    
        /* The process has been cancelled. */
        
        this.cancelPressed=true;

    }
    
    
    /**
     * Returns True if user pressed 'Cancel' button or False if not.
     * @return True if user pressed 'Cancel' button or False if not.
     */
    private boolean getPressedCancel(){
    
        /* Gets if the process was cancelled or not. */
        
        return this.cancelPressed;

    }    
    
        
    /**
     * Merges a file in memory.
     * @param fileToMerge File to merge in memory.
     * @return True if the process was properly finished or false if the process failed.
     */
    private boolean mergeFileInMemory(File fileToMerge){
    
        /* Merges the received file. */
        
        /* To return the result of the process. */
        boolean result = false;
        
        /* New file to merge. */
        FileReader frNewFile;                

        try {
            
            /* Opens the new file and merges it in memory. */
            
            frNewFile = new FileReader(fileToMerge);
            
            try (BufferedReader brNewFile = new BufferedReader(frNewFile)) {

                /* Header of the file. */
                String header=brNewFile.readLine();

                /* To check the header. */
                Utils util = new Utils();
                                
                if (util.isValidTXTFileHeader(header) == true){
                    
                    /* Header Ok. */
                    
                    /* To read every instance of newFile. */
                    String newLine=brNewFile.readLine();

                    /* While not eof. */
                    while (newLine != null && getPressedCancel()==false) {

                        /* # -> The line is a comment. */

                        if (!newLine.startsWith("#")){

                            /* Merges instance in memory. */
                            getInstances().add(newLine);

                        }

                        /* Reads another line from newFile. */
                        newLine = brNewFile.readLine();

                    }
                                    
                    /* The file has been properly merged. */
                    //brNewFile.close();   /* auto-closeable. */
                    frNewFile.close();

                    result = true;
                
                }

            }catch (IOException e){

                Logger.getLogger(RunCreationDataset.class.getName()).log(Level.SEVERE, null, e);
                
            }                        

        }catch (IOException e){

            Logger.getLogger(RunCreationDataset.class.getName()).log(Level.SEVERE, null, e);
        }
        
        return result;
    }

    
                  
    
    
    /**
     * Sorts all merged instances in ascending order.
     */
    private void sortInstances(){
    
        /* Sorts all merged instances in ascending order. */
        
        Collections.sort(getInstances(), new Comparator<String>() {

            @Override
            public int compare(final String instance1, final String instance2) {

                //#yr  mo dy hr mn
                //2011 12 31 23 50 -> field
                //0123456789012345 -> position
                
                /* Year */
                int yearInstance1 = Integer.parseInt(instance1.substring(0, 4));
                int yearInstance2 = Integer.parseInt(instance2.substring(0, 4));

                /* Month */
                int monthInstance1 = Integer.parseInt(instance1.substring(5, 7));
                int monthInstance2 = Integer.parseInt(instance2.substring(5, 7));

                /* Day */
                int dayInstance1 = Integer.parseInt(instance1.substring(8, 10));
                int dayInstance2 = Integer.parseInt(instance2.substring(8, 10));

                /* Hour */
                int hrInstance1 = Integer.parseInt(instance1.substring(11, 13));
                int hrInstance2 = Integer.parseInt(instance2.substring(11, 13));

                /* Minute */
                int mnInstance1 = Integer.parseInt(instance1.substring(14, 16));
                int mnInstance2 = Integer.parseInt(instance2.substring(14, 16));

                /* Result of comparation. */
                int c;

                /* Compares all fields and returns result. */
                c= Integer.compare(yearInstance1, yearInstance2);
                
                if (c == 0){

                    /* Equals. */
                    
                    c= Integer.compare(monthInstance1, monthInstance2);

                    if (c == 0){
                        
                        /* Equals. */
                        
                        c= Integer.compare(dayInstance1, dayInstance2);

                        if (c == 0){

                            /* Equals. */
                            
                            c= Integer.compare(hrInstance1, hrInstance2);

                            if (c == 0){

                                c = Integer.compare(mnInstance1, mnInstance2);
                            }
                        }
                    }
                }

                /* Result of comparation. */
                return c;

            }
        });                

    }    
            
    
    
    /**
     * Checks all merged instances in dataset looking for missing or duplicated dates.
     * @return The missing or duplicated dates found in dataset file.
     */
    private ArrayList<String> checkMissingDates(){        
    
        /* 
            Checks all merged instances in dataset looking for missing
            or duplicated dates.
        */                
        
        
        
        /* 
            *************************************************************
            Any change in this method has to be also done in the methods:
                checkMissingDates() of PreprocessDatasetFile.java
                reloadViewData()    of ControllerViewManageBuoys.java
            *************************************************************
        */

        
        
        /* To convert from int to String with two digits. */
        DecimalFormat intFormatter = new DecimalFormat("00");
        
        /* Utilities. */
        Utils util = new Utils();
        
        /* Instances merged in dataset. */
        ArrayList<String> instancesMerged = getInstances();
        
        /* Number of instances to check. */
        int numberOfInstances = instancesMerged.size();
        
        /* Indicates if a missing date has been found. */
        boolean missingDateFound;
        
        /* Missing or duplicated dates. */
        ArrayList<String> missingDates = new ArrayList<>();
        
        /* Format of the date. */
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy MM dd HH mm");
        
        /* NDBC dates are in UTC time zone. */
        TimeZone timeZone = TimeZone.getTimeZone("UTC");
        
        /* For getting correct time according to UTC time zone. */
        dateFormat.setTimeZone(timeZone);

        /* Time interval between date: 1 hour. */
        int timeInterval = 1;

        /* Maximum seconds of delay for a measurement: 360s --> 6 minutes: --> 10% of 60 minutes (1 hour). */
        long maxDelayInterval = 360;

        
        if(numberOfInstances>1){
        
            /* There are instances to check. */        


            /* Gets the first date. */
            String firstDateInStringFormat = instancesMerged.get(0).substring(0, 16);
            Calendar firstDateInDateFormat = util.convertDateFromStringToCalendar(firstDateInStringFormat);

            /* Second date. */
            String secondDateInStringFormat;
            Calendar secondDateInDateFormat;


            /* Check all instances. */
            for(int i=1;i<numberOfInstances && getPressedCancel()==false;i++){

                /* Gets the second date. */
                secondDateInStringFormat = instancesMerged.get(i).substring(0, 16);
                secondDateInDateFormat = util.convertDateFromStringToCalendar(secondDateInStringFormat);                                                               

                /* Checks if both dates are equals. */
                if(dateFormat.format(firstDateInDateFormat.getTime()).equals(dateFormat.format(secondDateInDateFormat.getTime()))==true){

                    /* Equals: -> Duplicate date. */

                    /* Month: + 1 because 0 -> January ... 11 -> December. */                
                    missingDates.add("Duplicated: "+ firstDateInDateFormat.get(Calendar.YEAR)+" "+
                                                                intFormatter.format((firstDateInDateFormat.get(Calendar.MONTH)+1))+" "+
                                                                intFormatter.format(firstDateInDateFormat.get(Calendar.DATE))+" "+
                                                                intFormatter.format(firstDateInDateFormat.get(Calendar.HOUR_OF_DAY))+" "+
                                                                intFormatter.format(firstDateInDateFormat.get(Calendar.MINUTE)));

                }else{

                    /* Not equals. */

                    do{                                    

                        /* Sets previous expected date. */
                        String previousFirstDateInStringFormat = firstDateInDateFormat.get(Calendar.YEAR)+" "+
                                                                  intFormatter.format((firstDateInDateFormat.get(Calendar.MONTH)+1))+" "+
                                                                  intFormatter.format(firstDateInDateFormat.get(Calendar.DATE))+" "+
                                                                  intFormatter.format(firstDateInDateFormat.get(Calendar.HOUR_OF_DAY))+" "+
                                                                  intFormatter.format(firstDateInDateFormat.get(Calendar.MINUTE));

                        /* Gets the next expected date. */
                        firstDateInDateFormat.add(Calendar.HOUR_OF_DAY, timeInterval);
                        
                        /* Checks if second date is the expected one. */
                        if(dateFormat.format(firstDateInDateFormat.getTime()).equals(dateFormat.format(secondDateInDateFormat.getTime()))==false){

                            /* 
                                Checks if the second date matchs with the maximum delay.
                            */
                            if(Math.abs(firstDateInDateFormat.getTime().getTime()-secondDateInDateFormat.getTime().getTime()) / 1000  > maxDelayInterval){

                                /* The second date exceeds the maximum delay. */
                                
                                if(secondDateInDateFormat.getTime().before(firstDateInDateFormat.getTime()) == false){

                                    /* Missing date found. */

                                    /* Month: + 1 because 0 -> January ... 11 -> December. */                
                                    missingDates.add("Missing: "+firstDateInDateFormat.get(Calendar.YEAR)+" "+
                                                                            intFormatter.format((firstDateInDateFormat.get(Calendar.MONTH)+1))+" "+
                                                                            intFormatter.format(firstDateInDateFormat.get(Calendar.DATE))+" "+
                                                                            intFormatter.format(firstDateInDateFormat.get(Calendar.HOUR_OF_DAY))+" "+
                                                                            intFormatter.format(firstDateInDateFormat.get(Calendar.MINUTE)));
                                    missingDateFound=true;
                                    
                                }else{

                                    /* An expected date. */
                                    
                                    missingDates.add("    Unexpected date: "+secondDateInDateFormat.get(Calendar.YEAR)+" "+
                                                                            intFormatter.format((secondDateInDateFormat.get(Calendar.MONTH)+1))+" "+
                                                                            intFormatter.format(secondDateInDateFormat.get(Calendar.DATE))+" "+
                                                                            intFormatter.format(secondDateInDateFormat.get(Calendar.HOUR_OF_DAY))+" "+
                                                                            intFormatter.format(secondDateInDateFormat.get(Calendar.MINUTE)));

                                    missingDateFound=false;

                                    /* Sets the previous expected second date. */
                                    secondDateInStringFormat= previousFirstDateInStringFormat;
                                    
                                }
                                
                            }else{
                                    
                                /* 
                                    The buoy took the measurement from: hh:50 to: hh:49, hh:48, hh:47, hh:46, hh:45, hh:44.
                                                                                    or
                                                                                  hh:51, hh:52, hh:53, hh:54, hh:55, hh:56.
                                */
                                missingDateFound=false;                                
                                                               
                                /* Sets the expected second date. */
                                secondDateInStringFormat= firstDateInDateFormat.get(Calendar.YEAR)+" "+
                                                                intFormatter.format((firstDateInDateFormat.get(Calendar.MONTH)+1))+" "+
                                                                intFormatter.format(firstDateInDateFormat.get(Calendar.DATE))+" "+
                                                                intFormatter.format(firstDateInDateFormat.get(Calendar.HOUR_OF_DAY))+" "+
                                                                intFormatter.format(firstDateInDateFormat.get(Calendar.MINUTE));
                            }

                        }else{

                            /* Ok. */
                            missingDateFound=false;
                        }
                        
                    }while(missingDateFound==true);

                }

                /* Sets the first date. */
                firstDateInStringFormat = secondDateInStringFormat;
                firstDateInDateFormat = util.convertDateFromStringToCalendar(firstDateInStringFormat);

            }
        
        }
        
        return missingDates;
                
    }             
    


    /**
     * Creates the SwingWorker and starts the process.
     */
    public void startCreationDataset(){
    
        /* Enables Cancel button. */        
        btnCancel.setEnabled(true);
        
        /* Clears the text area that shows the status of the process. */
        txtArea.setText("");
        
        /* SwingWorker that will create the dataset file. */
        worker = new SwingWorker<Void, String>(){
        
            @Override
            protected Void doInBackground() throws Exception {
                                                
                /* Information to save in .XML file. */
                DatasetInformation datasetInfo = new DatasetInformation();
                                
                /* Sets file name dataset. */
                datasetInfo.setFileNameDataset(getDatasetFilename().getName());

                
                publish("Creation started.\n\n");
                publish("   Creating intermediate dataset: " + getDatasetFilename().getName() + "\n\n");
                publish("      Merging annual text files.\n");

                
                /* Merges all TXT files in memory. */
                                       
                for(File newFile : getFiles()){

                    /* Checks if user pressed Cancel or there was an error. */

                    if (isCancelled()==false){

                        publish("         Merging: " + newFile.getName() + "\n");

                        if(mergeFileInMemory(newFile) == true){
                
                            /* The file was properly merged in memory. */
                
                            /* Adds the file to .XML information. */
                            datasetInfo.getTXTFiles().add(newFile.getName());
                
                        }else{
                
                            /* There was an error while merging the file. */
                
                            /* Cancels the process. */

                            publish("            Error while merging file:" +  newFile.getName() + "\n");
                            btnCancel.doClick();

                        }
                    }
                }

                /* Checks if user pressed Cancel or there was an error. */
                if (isCancelled()==false){
                          
                    publish("      Done.\n\n");
                    publish("      Sorting instances.\n");
                
                    /* Sorts all the instances in ascending order. */

                    sortInstances();
                }
                
                
                /* Checks if user pressed Cancel or there was an error. */
                if (isCancelled()==false){
                    
                    publish("      Done.\n\n");
                    publish("      Saving intermediate dataset.\n");

                    
                    /* Creates the dataset file received. */

                    /* Header of the file (the same as TXT file. ). */
                    final String headerDatasetFile="#YY  MM DD hh mm WDIR WSPD GST  WVHT   DPD   APD MWD   PRES  ATMP  WTMP  DEWP  VIS  TIDE";

                    FileWriter fwDatasetFile = new FileWriter(getDatasetFilename(), true);                    
                    
                    try (BufferedWriter bwDatasetFile = new BufferedWriter(fwDatasetFile)) {
                        
                        /* Sets date of creation. */
                        datasetInfo.setDateCreation(Calendar.getInstance());
                        
                        /* Sets header. */
                        datasetInfo.setHeaderDatasetFile(headerDatasetFile);                        

                        /* Sets short description. */
                        datasetInfo.setShortDescription(shortDescription);
                        
                        
                        /* Saves header. */
                        bwDatasetFile.write(headerDatasetFile);
                        bwDatasetFile.newLine();
                        
                        
                        /* Save all instances in dataset. */                       
                        for (String newLine : getInstances()) {
                            
                            /* Writes an instance and LF. */
                            
                            bwDatasetFile.write(newLine);
                            bwDatasetFile.newLine();
                        }
                                                
                        /* All instances have been merged. */
                        //bwDatasetFile.close();  /* auto-closeable. */
                        //fwDatasetFile.close();  /* auto-closeable. */
                                                                        
                    }catch (IOException e){
                        
                        /* Cancel the process. */
                            
                        publish("         Error while saving intermediate dataset.\n");
                        btnCancel.doClick();
                            
                    }
                }
                
                
                /* Checks if user pressed Cancel or there was an error. */
                if (isCancelled()==false){
                                           
                    /* Sets number of instances. */
                    datasetInfo.setNumInstances(getInstances().size());

                    /* Sorts TXT files by name. */
                    Collections.sort(datasetInfo.getTXTFiles());
                    
                    /* Sets first date of dataset file. */
                    datasetInfo.setFirstDate(getInstances().get(0).substring(0, 16));
                                        
                
                    /* Sets last date of dataset file. */
                    datasetInfo.setLastDate(getInstances().get(datasetInfo.getNumInstances()-1).substring(0, 16));
                       
                    publish("      Done.\n\n");
                    publish("      Checking missing or duplicated dates in intermediate dataset.\n");
                    
                    /* Gets missing or duplicated dates in dataset created. */
                    ArrayList<String> missingDates = checkMissingDates();
                    
                    /* Sets missing/duplicated dates in dataset created. */
                    datasetInfo.setMissingDates(missingDates);

                    /* Checks if user pressed Cancel or there was an error. */
                    if (isCancelled()==false){
                    
                        /* Disables Cancel button because the process has finished. */
                        btnCancel.setEnabled(false);
                    
                        /* Checks if missing/duplicated dates were found. */
                        if(missingDates.isEmpty()==false){

                            /* Shows missing/duplicated dates found. */

                            for(String missingDate: missingDates){

                                publish("          " + missingDate +"\n");

                            }

                        }else{

                            /* None missing or duplicated date was found. */
                            publish("        None missing or duplicated dates were found.\n");

                        }

                        publish("\n      Done.\n");

                        /* Creates the .XML file. */
                        XMLFile<DatasetInformation> xmlFile = new XMLFile<>(DatasetInformation.class, getXMLFilename());

                        if (xmlFile.writeXMLFile(datasetInfo) == false){

                            /* Cancels the process. */
                            publish("   Error while saving " + xmlFile.getFileName().getName() + " file on disk:\n\n");
                            btnCancel.doClick();

                        }
                    
                    }
                }

                /* Checks if user pressed Cancel or there was an error. */
                if (isCancelled()==false){
                        
                    /* The process has finished.  */
                    
                    publish("   Done.\n");
                        
                }

                /* The SwingWorker has finished the job. */                
                return null;
            }

            
            @Override
            protected void process(List<String> data){
                
                for(String line : data){
                    
                    /* Sends information received about the process to status window. */
                    
                    txtArea.append(line);
                }
            }

            
            @Override
            protected void done(){

                /* The process has finished. Need to check if it was cancelled or not. */

                if(isCancelled()){
                    
                    /* The process was cancelled by user request or there was an error. */

                    txtArea.append("\nCreation cancelled.\n");
                    
                }else{
                    
                    /* The process has finished properly. */                    
                    
                    btnCancel.setEnabled(false);                    
                    txtArea.append("\nCreation finished properly.\n");
                    
                }

                /* This button allows the user to close the window and back. */
                btnOK.setEnabled(true);                                        
            }
        
        };
        
        
        /* SwingWorker starts creating the dataset file. */
        worker.execute();
    
    }
    
    

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        btnOK = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        txtArea = new javax.swing.JTextArea();
        lblStatus = new javax.swing.JLabel();
        btnCancel = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
        setTitle("SPAMDA 1.0-Creating intermediate dataset file");
        setResizable(false);

        btnOK.setText("Ok");
        btnOK.setEnabled(false);
        btnOK.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnOKActionPerformed(evt);
            }
        });

        txtArea.setColumns(20);
        txtArea.setRows(5);
        txtArea.setName(""); // NOI18N
        jScrollPane1.setViewportView(txtArea);

        lblStatus.setText("Status:");

        btnCancel.setText("Cancel creation");
        btnCancel.setToolTipText("Cancel creation of intermediate dataset.");
        btnCancel.setEnabled(false);
        btnCancel.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCancelActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jScrollPane1)
                    .addComponent(lblStatus, javax.swing.GroupLayout.Alignment.LEADING))
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addGap(69, 69, 69)
                .addComponent(btnCancel, javax.swing.GroupLayout.PREFERRED_SIZE, 162, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(44, 44, 44)
                .addComponent(btnOK, javax.swing.GroupLayout.PREFERRED_SIZE, 103, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(68, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(lblStatus)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 260, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnOK)
                    .addComponent(btnCancel))
                .addContainerGap())
        );

        pack();
        setLocationRelativeTo(null);
    }// </editor-fold>//GEN-END:initComponents

    private void btnOKActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnOKActionPerformed

        /* If process was cancelled deletes dataset and .XML files if exist. */
        
        if(getPressedCancel()==true){
            
            /* Deletes dataset file. */
            if(getDatasetFilename().exists()){

                getDatasetFilename().delete();

            }

            /* Deletes .XML file. */
            if(getXMLFilename().exists()){

                getXMLFilename().delete();

            }                                        
        
        }

        /* Closes the JDialog. */
        this.dispose();
        
    }//GEN-LAST:event_btnOKActionPerformed

    private void btnCancelActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCancelActionPerformed
        
        /* Disables Cancel button. */
        btnCancel.setEnabled(false);
        
        /* Cancels the process. */
        setPressedCancel();
        worker.cancel(true);

    }//GEN-LAST:event_btnCancelActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnCancel;
    private javax.swing.JButton btnOK;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel lblStatus;
    private javax.swing.JTextArea txtArea;
    // End of variables declaration//GEN-END:variables
}
