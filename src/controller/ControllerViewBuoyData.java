/*
SPAMDA: Software for Pre-processing and Analysis of Meteorological DAta to build datasets

Copyright (c) 2017-2021 by AYRNA Research Group. https://www.uco.es/ayrna/
    Authors: 
      Gómez-Orellana, A.M.; Fernández, J.C.; Dorado-Moreno, M.; Gutiérrez, P.A.; Hervás-Martínez, C.
      Building Suitable Datasets for Soft Computing and Machine Learning Techniques from Meteorological
       Data Integration: A Case Study for Predicting Significant Wave Height and Energy Flux.
      Energies 2021, 14, 468. https://doi.org/10.3390/en14020468                                                                       

This program is free software: you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software Foundation,
either version 3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program,
in the file COPYING. If not, see <http://www.gnu.org/licenses/>.

Additional permissions under GNU GPL version 3 section 7:
1. Redistributions of source code, with or without modification, must retain
the above full copyright notice as author attributions.

2. Redistributions in binary form and/or the use of the documentation,
with or without modification, must reproduce the above full copyright notice
as author attributions in the documentation and/or materials provided with
the distribution.

3. Modified versions of source code and/or documentation, as well as binary
distributions, must be marked in reasonable ways as different from the original version.

4. Neither name of copyright holders nor the names of its contributors may be used
to endorse or promote products derived from this software for publicity purposes
without specific prior written permission.

5. Redistribution and/or use of source code, binary format and documentation,
with or without modification, could require indemnification of licensors
and authors by anyone who conveys the material (or modified versions of it)
with contractual assumptions of liability to the recipient, for any liability
that these contractual assumptions directly impose on those licensors and authors.

SPAMDA uses some external libraries. You can see their respective notices about license,
copyright and disclaimer in the following files. For a more complete information about
such licenses, see the distributions provided by their authors:
-Library NetCDF Java, version 4.6.10
	Notice of license in the file NetCDF-LICENSE
-Library SLF4J, version 1.7.25
	Notice of license in the file SLF4J-LICENSE
-Library WEKA, version 3.8.1
	Notice of license in the file WEKA-LICENSE

Contact information:
Antonio Manuel Gomez Orellana, Mr.
email: am[dot]gomez[at]uco[dot]es
Address: University of Cordoba, Department of Computer Science
and Numerical Analysis, AYRNA Research Group, Rabanales Campus,
Einstein Building, 3rd floor. Road Madrid-Cadiz, Km 396-A.
14071 - Cordoba (Spain).

Juan Carlos Fernandez Caballero, PhD.
email: jfcaballero[at]uco[dot]es
Address: University of Cordoba, Department of Computer Science
and Numerical Analysis, AYRNA Research Group, Rabanales Campus,
Einstein Building, 3rd floor. Road Madrid-Cadiz, Km 396-A.
14071 - Cordoba (Spain).
 */

package controller;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JOptionPane;
import javax.swing.table.DefaultTableModel;
import model.BuoyDatabase;
import view.interfaces.InterfaceViewBuoyData;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.nio.file.Files;
import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Locale;
import javax.swing.DefaultListModel;
import javax.swing.JFileChooser;
import javax.swing.filechooser.FileNameExtensionFilter;
import utils.Utils;



/**
 * This class defines the controller for managing the events generated by the view BuoyData.
 * 
 */
public class ControllerViewBuoyData implements ActionListener, FocusListener {
    
    
    /**
     * View.
     */
    private final InterfaceViewBuoyData view;     
    
    
    /**
     * Buoys's information.
     */        
    private DefaultTableModel datamodel;          
    
    
    /**
     * Selected row to modify.
     */                
    private final int selectedRow;                
    
    
    /**
     * Files's names that belong to the buoy.
     */    
    private DefaultListModel<String> listModel;   

    
    /**
     * Path of each .TXT file that belongs to the buoy.
     */        
    private ArrayList<String> pathFiles;          

    
    /* Methods of the class */
    
    
    /**
     * Constructor.
     * @param view View that this controller will manage.
     * @param datamodel Buoys's information.
     * @param selectedRow Selected row in Managebuoys.
     */
    public ControllerViewBuoyData(InterfaceViewBuoyData view, DefaultTableModel datamodel, int selectedRow){

        /* Sets View */
        this.view = view;
        this.datamodel=datamodel;
        this.selectedRow=selectedRow;
        
        /* Initializes values. */
        this.pathFiles=new ArrayList<>();
        this.listModel=new DefaultListModel<>();
        
        if(selectedRow!=-1){
                       
            /* The user is updating a buoy. */
            
            /* Utilities. */
            Utils util = new Utils();
            
            /* Search for the .TXT files that belong to the buoy. */            
            util.searchFiles((int)datamodel.getValueAt(selectedRow, 0), this.listModel, new ArrayList<>(Arrays.asList("TXTinFiles")), this.pathFiles, new ArrayList<>(Arrays.asList("TXT Files", "TXT", "txt")));

        }
        
        this.view.setListModel(this.listModel);

    }

    
    /**
     * Returns view.
     * @return View.
     */
    private InterfaceViewBuoyData getView(){
        
        /* Returns view */
        return view;
        
    }
    
    
    /**
     * Returns buoys's information.
     * @return Buoys's information.
     */
    public DefaultTableModel getDataModel(){
        
        /* Returns datamodel */
        return datamodel;
        
    }
    
    
    /**
     * Returns selected buoy to modify.
     * @return Selected buoy to modify.
     */
    public int getSelectedRow(){
        
        /* Returns row to modify. */
        return selectedRow;
        
    }

    
    /**
     * Returns paths of the files that belong to the buoy.
     * @return Paths of the files that belong to the buoy.
     */
    public ArrayList<String> getPathFiles(){
    
        /* Gets full path of files that belong to the buoy. */
        
        return pathFiles;

    }

    
    /**
     * Returns the model of the list that shows the files that belong to the buoy.
     * @return The model of the list that shows the files that belong to the buoy.
     */
    public DefaultListModel<String> getListModel(){
    
        /* Gets the model of the list that shows the files that belong to the buoy. */
        
        return listModel;

    }        
    
    
    /**
     * Manages events generated in the view.
     * @param event Event generated in the view.
     */
    @Override
    public void actionPerformed(ActionEvent event){

        /* Manages the event generated in the view. */
        
        /* Gets the event name.*/
        String eventName = event.getActionCommand();
        
        switch (eventName) {
            
            case InterfaceViewBuoyData.SAVE_BUOY:
                
                /* Action SAVE_BUOY clicked. */              
                if (doSaveBuoy()){
                    
                    /* Only when modifying the buoy the view is closed. */
                    doCancel();
                    
                }else{
                    
                    this.getView().setDefaultFocus();
                
                }
                
                break;
    
            case InterfaceViewBuoyData.CLEAR_BUOY:
                
                /* Action CLEAR_BUOY clicked. */
                doClearBuoyData();
                break;

            case InterfaceViewBuoyData.CANCEL:
                
                /* Action EXIT clicked. */
                doCancel();
                break;

            case InterfaceViewBuoyData.ADD_TXT_FILE:
                
                /* Action ADD_TXT_FILE clicked. */
                doAddTXTFiles();
                break;

            case InterfaceViewBuoyData.DELETE_TXT_FILE:
                
                /* Action DELETE_TXT_FILE clicked. */
                doDeleteTXTFile();
                break;

            case InterfaceViewBuoyData.CHANGE_LATITUDE_NOTATION:
                
                /* Action CHANGE_LATITUDE_NOTATION clicked. */
                doRecalculateCoordinatesNotations();
                break;

            case InterfaceViewBuoyData.CHANGE_LONGITUDE_NOTATION:
                
                /* Action CHANGE_LONGITUDE_NOTATION clicked. */
                doRecalculateCoordinatesNotations();
                break;

            case InterfaceViewBuoyData.HELP:
                
                /* Action HELP clicked. */
                doHelp();
                break;
                
            default:
                
                /* Event not defined. */
                
                JOptionPane.showMessageDialog(null, "Event not defined:" + eventName + ".", "Error", JOptionPane.ERROR_MESSAGE);
                break;
        }

    }
    
    
    @Override
    public void focusGained(FocusEvent e) {

    }


    @Override
    public void focusLost(FocusEvent e) {
        
        /* 
           The user has changed the latitude or longitude coordinates,
           recalcule other notations.
        */
        
        doRecalculateCoordinatesNotations();
        
    }
        
    
    
    
    /* Methods for processing each event (what user clicked on view). */    
   
    
    
    /**
     * Updates buoy's information in database.
     * @return True if the buoy was properly updated in database or False if not.
     */    
    private boolean doSaveBuoy(){
        
        boolean result=false;
        
        if(getSelectedRow()==-1){

            /* Inserts a new buoy. */
            doInsertNewBuoy();

        }else{
            
            /* Modifys the selected buoy. */
            result=doModifyBuoy();
            
        }
        
        return result;
        
    }
    
    
    /**
     * Inserts a new buoy in database.
     */
    private void doInsertNewBuoy(){
        
        /* Inserts a new buoy in database. */
        
        /* Information about buoy. */
        String stationID = getView().getBuoyStationID();
        String description = getView().getBuoyDescription();

        String latitude = getView().getBuoyLatitude();
        String latitudeNS = getView().getBuoyLatitudeNS();

        String longitude = getView().getBuoyLongitude();
        String longitudeWE = getView().getBuoyLongitudeEW();
        int txtnumfiles = getListModel().getSize();
        
        /* To know if all fields are correctly filled. */
        boolean check = checkFields(stationID, description, latitude, longitude);
        
        
        /* Checks fields are filled. */
        
        if(check == true){                   
        
            /* Inserts buoy in database. */
            
            /* Checks StationID is unique. */            
            if (checkStationID(getView().getBuoyStationID(), -1) == false){
                
                JOptionPane.showMessageDialog(null, "The StationID already exists in database.", "Warning", JOptionPane.WARNING_MESSAGE);
                
            }else{
            
                int id;
                BuoyDatabase buoyDatabase = new BuoyDatabase();
                
                if(buoyDatabase.connect()==true){

                    id=buoyDatabase.insertBuoy(stationID, description, Double.parseDouble(latitude), latitudeNS, Double.parseDouble(longitude), longitudeWE, txtnumfiles);
                    buoyDatabase.disconnect();

                    /* Checks if the new buoy was successfully inserted in database. */
                    if(id==-1){
                        JOptionPane.showMessageDialog(null, "The new buoy was not inserted in database.", "Error", JOptionPane.ERROR_MESSAGE);
                    }else{

                        /* Updates the model with the new buoy. */
                        getDataModel().addRow(new Object[]{id, stationID, description, latitude, latitudeNS, longitude, longitudeWE, txtnumfiles});

                        /* Creates folders where saving the files with information about the buoy:
                                idBuoy
                                  | -> TXTinFiles
                                  | -> Datasets (of TXTinFiles)
                                  | -> Preprocess (of Datasets)
                                  | -> Matching
                         */

                        /* Root that will contain all folders and files about buoy. */
                        String root = System.getProperty("user.dir", ".")+File.separator+"DB"
                                      +File.separator+"id"+Integer.toString(id);

                        Utils util = new Utils();

                        util.createDirectory(root);
                        util.createDirectory(root+File.separator+"TXTinFiles");
                        util.createDirectory(root+File.separator+"Datasets");
                        util.createDirectory(root+File.separator+"Preprocess");
                        util.createDirectory(root+File.separator+"Matching");

                        JOptionPane.showMessageDialog(null, "The new buoy was successfully inserted in database.", "Message", JOptionPane.INFORMATION_MESSAGE);

                        /* Copy the selected files by user. */
                        copySelectedFiles(Integer.toString(id));


                        /* Clears list with files to be copied. */
                        getListModel().clear();
                        getPathFiles().clear();


                        /* Clears data of each field. */
                        getView().clearFields();
                        getView().setDefaultFocus();
                    }                
                
                }else{
        
                    JOptionPane.showMessageDialog(null, "There was an error when connecting to database.", "Error", JOptionPane.ERROR_MESSAGE);
            
                }
                
            }            
        }
    }
    

    
    /**
     * Modify buoy's information in database.
     * @return True if the buoy was properly updated in database or False if not.
     */    
    private boolean doModifyBuoy(){
        
        /* Modify buoy in database. */
        
        /* Information about buoy. */
        String stationID = getView().getBuoyStationID();
        String description = getView().getBuoyDescription();

        String latitude = getView().getBuoyLatitude();
        String latitudeNS = getView().getBuoyLatitudeNS();

        String longitude = getView().getBuoyLongitude();
        String longitudeWE = getView().getBuoyLongitudeEW();        

        int txtnumfiles;
                
        boolean result=false;
            
                
        /* To know if all fields are correctly filled. */
        boolean check = checkFields(stationID, description, latitude, longitude);
        
        
        /* Checks fields are filled. */
        
        if(check == true){
            
            /* Row and id (buoy) selected by user to modify. */
            int row= getSelectedRow();
            int idBuoy = (int) datamodel.getValueAt(row, 0);
       
            
            /* Checks StationID is unique. */            
            if (checkStationID(getView().getBuoyStationID(), row) == false){
                
                JOptionPane.showMessageDialog(null, "The StationID already exists in database.", "Warning", JOptionPane.WARNING_MESSAGE);
                
            }else{
                
                /* Delete the selected files by user. */
                deleteSelectedFiles(Integer.toString(idBuoy));
                    
                /* Copy the selected files by user. */
                copySelectedFiles(Integer.toString(idBuoy));

                /* Gets number of TXT files of the buoy. */
                txtnumfiles=numTXTFiles(Integer.toString(idBuoy));
               
                
                /* Updates buoy information in database. */
            
                /* Information about buoys. */
                DefaultTableModel datamodelBuoys = getDataModel();
                                    
                /* Connects to database and updates the buoy. */
                BuoyDatabase buoyDatabase = new BuoyDatabase();
                
                if(buoyDatabase.connect()==true){

                    result=buoyDatabase.updateBuoy(idBuoy, stationID, description, Double.parseDouble(latitude), latitudeNS, Double.parseDouble(longitude), longitudeWE, txtnumfiles);

                    buoyDatabase.disconnect();

                    /* Checks if the buoy was successfully updated in database. */
                    if(!result){
                        JOptionPane.showMessageDialog(null, "The buoy was not updated in database.", "Error", JOptionPane.ERROR_MESSAGE);
                    }else{

                        /* Updates the model with the new buoy. */
                        datamodelBuoys.setValueAt(stationID, row, 1);
                        datamodelBuoys.setValueAt(description, row, 2);
                        datamodelBuoys.setValueAt(latitude, row, 3);
                        datamodelBuoys.setValueAt(latitudeNS, row, 4);
                        datamodelBuoys.setValueAt(longitude, row, 5);
                        datamodelBuoys.setValueAt(longitudeWE, row, 6);
                        datamodelBuoys.setValueAt(txtnumfiles, row, 7);

                        JOptionPane.showMessageDialog(null, "The buoy was successfully updated in database.", "Message", JOptionPane.INFORMATION_MESSAGE);                

                    }
                
                }else{
        
                    JOptionPane.showMessageDialog(null, "There was an error when connecting to database.", "Error", JOptionPane.ERROR_MESSAGE);
            
                }

                
            }
        }
        
        return result;
                
    }
    
    
    
    /**
     * Checks each field's data typed by user.
     * @param stationID Buoy's name.
     * @param description Buoy's description.
     * @param latitude Buoy's latitude.
     * @param longitude Buoy's longitude.
     * @return True if each field's data is valid or false if not.
     */    
    private boolean checkFields(String stationID, String description, String latitude, String longitude){
                
        /* Result of checking fields data. */
        boolean result = false;
                
        /* Checks if all fields are correctly filled. */
        if(stationID.trim().equals("") || description.trim().equals("")){

            JOptionPane.showMessageDialog(null, "StationID and Description must be filled before saving the buoy.", "Message", JOptionPane.INFORMATION_MESSAGE);
                        
        }else if(stationID.length()>20){
            
            JOptionPane.showMessageDialog(null, "Maximum length for Station ID is 20 characters.", "Message", JOptionPane.INFORMATION_MESSAGE);                        
        
        }else if(description.length()>60){
            
            JOptionPane.showMessageDialog(null, "Maximum length for Description is 60 characters.", "Message", JOptionPane.INFORMATION_MESSAGE);                        
            
        }else if(isValidLatitude(latitude) == false){            
            
            JOptionPane.showMessageDialog(null, "Latitude must be in the [0, 90] range (with five decimal digits).", "Message", JOptionPane.INFORMATION_MESSAGE);
                                  
        }else if(isValidLongitude(longitude) == false){
            
            JOptionPane.showMessageDialog(null, "Longitude must be in the [0, 180] range (with five decimal digits).", "Message", JOptionPane.INFORMATION_MESSAGE);
                                   
        }else{
            
            /* All fields are correctly filled. */
            result = true;
        
        }

        return result;
    
    }
    

    /**
     * Checks if buoy's name typed by user does not exist in database (is unique).
     * @param stationID Buoy's name.
     * @param row Selected row.
     * @return True if buoys's name is unique or false if not.
     */        
    private boolean checkStationID(String stationID, int row){
        
        /* Checks StationID is unique in model. */
        
        /* TableModel */
        DefaultTableModel model = getDataModel();
               
        /* Number of buoys in datamodel. */
        int numBuoys = model.getRowCount();
        
        /* To check if StationID is unique or not. */
        boolean unique=true;
        
        /* Checks all buoys StationID's except i==row. */        
        for(int i=0;(i<numBuoys && unique==true);i++){
            
            if ( ((String) model.getValueAt(i, 1)).equalsIgnoreCase(stationID) && i!=row) {
            
                unique = false;
                
            }        
        }
                
        return unique;
        
    }
        

    /**
     * Clears data of everfy field in form and sets default focus.
     */
    private void doClearBuoyData(){
        
        /* Clears data of every field in form. */
        getView().clearFields();
        
        /* Sets default focus in view. */
        getView().setDefaultFocus();
        
    }
                    

    
    /**
     * Shows a dialog for choosing the .TXT files that user wants to add to the buoy.
     */    
    private void doAddTXTFiles(){
        
        /* Shows a dialog for choosing the TXT files to add. */

        /* Dialog. */
        javax.swing.JFileChooser txtFileChooser = new javax.swing.JFileChooser();
        
        /* Enables multiselect files. */
        txtFileChooser.setMultiSelectionEnabled(true);
        
        /* Disables All files option. */
        txtFileChooser.setAcceptAllFileFilterUsed(false);
        
        /* TXT, txt file extension filter. */
        FileNameExtensionFilter filter = new FileNameExtensionFilter("TXT Files", "TXT", "txt");

        /* Path for searching TXT files. */
        String path = System.getProperty("user.dir", ".");
              
        /* Sets path and filter to the dialog. */
        txtFileChooser.setCurrentDirectory(new File(path));
        txtFileChooser.setFileFilter(filter);  
                
        /* Shows dialog and waits for user selection. */       
        int returnVal = txtFileChooser.showOpenDialog(null);

        /* Checks user selection. */
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            
            /* The user selected a/several files. */
            
            /* Add the selected file/s. */

            addSelectionFiles(txtFileChooser.getSelectedFiles());

        }        
    }


    
    /**
     * Adds the selected .TXT files by user.
     * @param filesPathSelected Files selected by user.
     */
    private void addSelectionFiles(File[] filesPathSelected){
        
        /* Add the selected file/s by user. */
        
        /* To check both headers. */
        Utils util = new Utils();
        
        /* To show all files to be copied in a message. */
        String filesTobeCopied = "";
        
        for (File file : filesPathSelected) {
            
            /* Selected file. */
            String filename=file.getName();
            
            /* Checks if file exists. */            
            if (file.exists()==true){
            
                if(filename.toLowerCase().endsWith(".txt")){
                    
                    /* The selected file has .TXT extension. */
                    
                    /* Checks the format of the file. */
                                    
                    /* To show the line in case of error. */
                    int numLine=util.isValidAnnualTextFile(file);
                
                    if(numLine==0){
                
                        /* The selected file has the expected format. */

                        /* Copy the selected file by user. */

                        if(alreadySelectedFile(file, getPathFiles())==-1){

                            /* The selected file is a new file. */

                            /* Only filename. */
                            getListModel().addElement(filename + " (new)");

                            /* Path in case user want to delete it. */
                            getPathFiles().add(file.toString());

                            filesTobeCopied = filesTobeCopied + "      " + filename + "\n";

                        }else{

                            JOptionPane.showMessageDialog(null, "File "+ filename +" already selected.", "Warning", JOptionPane.WARNING_MESSAGE);
                        }
                        
                    }else{
                        
                        /* The selected file has not the expected format. */
                        JOptionPane.showMessageDialog(null, "File "+ filename +" has not the expected format.\n\nAn error was found in line number: " + numLine, "Warning", JOptionPane.WARNING_MESSAGE);
                            
                    }
                }else{

                    /* The selected file has not .TXT extension. */

                    JOptionPane.showMessageDialog(null, "File " + filename + " has not TXT extension.", "Warning", JOptionPane.WARNING_MESSAGE);

                }        
            }else{
            
                /* The selected file does not exist. */

                JOptionPane.showMessageDialog(null, "File " + filename + " does not exist.", "Warning", JOptionPane.WARNING_MESSAGE);
            
            }
        }  
        
        if(filesTobeCopied.isEmpty()==false){
            
            JOptionPane.showMessageDialog(null, "The following files:\n\n"+filesTobeCopied+"\nwill be copied after saving the buoy in database.", "Message", JOptionPane.INFORMATION_MESSAGE);
            
        }        
        
    }


    /**
     * Checks if a .TXT file is already selected by user.
     * @param file File to check.
     * @param pathSelectedFiles Files already selected by user.
     * @return -1 if file is not already selected or 1 if it is.
     */
    private int alreadySelectedFile(File file, ArrayList<String> pathSelectedFiles){
        
        /* The file received is not already selected. */
        int result = -1;
        
        /* Size of selected files. */
        int numFiles = pathSelectedFiles.size();
        
        for(int i=0; (i<numFiles && result==-1); i++){
            
            if(file.toString().equals(pathSelectedFiles.get(i))){
                
                /* The file is already selected. */
                result = i;
            }
        }
        
        return result;
        
    }
                    

    /**
     * Deletes the selected .TXT file by user.
     */
    private void doDeleteTXTFile(){
        
        /* Deletes from jlstFiles the selected file by user. */
        
        /* File to be deleted. */
        int selectedIndex = getView().getSelectedIndex();

        if(selectedIndex==-1){
            
            JOptionPane.showMessageDialog(null, "Please, select a file to delete.", "Message", JOptionPane.INFORMATION_MESSAGE);
        
        }else{

            String filename = getListModel().getElementAt(selectedIndex);
            
            if(getSelectedRow()==-1){

                /* The user is creating a new buoy. */
            
                /* The selected file will not be copied after inserting the new buoy. */

                /* Deletes selected file. */
                getListModel().remove(selectedIndex);
                getPathFiles().remove(selectedIndex);
            
                JOptionPane.showMessageDialog(null, "The file "+filename+" will not be copied after saving the buoy in database.", "Message", JOptionPane.INFORMATION_MESSAGE);                
                        
            }else{
            
                /* The user is modifying a buoy. */
                /* Asks the user that really want to delete the selected file. */                
                
                Object[] options = {"Cancel", "Delete"};
                
                if (JOptionPane.showOptionDialog(null, "Attention !!\nThe information in file "+filename+" will be erased.\n"
                        +"¿Do you to want to delete it?\n\n","Warning",
                        JOptionPane.DEFAULT_OPTION, JOptionPane.WARNING_MESSAGE, null,options, options[0])==1){

                    /* Deletes selected file. */
                    getListModel().remove(selectedIndex);
                    getPathFiles().remove(selectedIndex);
            
                    JOptionPane.showMessageDialog(null, "The file "+filename+" will be deleted after saving the buoy in database.", "Message", JOptionPane.INFORMATION_MESSAGE);
                }
            }
        }
    }
                 
    
    
    /**
     * Shows notations of coordinates (latitude / longitude) typed by user.
     */    
    private void doRecalculateCoordinatesNotations(){
    
        /* Calculates other coordinates notations. */
        
        /* To check if both longitute and latitude are valid. */
        boolean coordinatesOK = true;
        
        String latitudeTyped = getView().getBuoyLatitude();
        String longitudeTyped = getView().getBuoyLongitude();
        
        if(isValidLatitude(latitudeTyped)==false){                    
                    
            JOptionPane.showMessageDialog(null, "Latitude must be in the [0, 90] range (with five decimal digits).", "Message", JOptionPane.INFORMATION_MESSAGE);
            coordinatesOK = false;
                
        }

        if(isValidLongitude(longitudeTyped)==false){
                    
            JOptionPane.showMessageDialog(null, "Longitude must be in the [0, 180] range (with five decimal digits).", "Message", JOptionPane.INFORMATION_MESSAGE);                
            coordinatesOK = false;
                
        }
        
        /* Shows new notations if coordinates are valid. */
        
        if(coordinatesOK == true){
            
            /* To show latitude and longitude with 4 decimals and point separator. */
            DecimalFormat decimalFormat = new DecimalFormat("0", DecimalFormatSymbols.getInstance(Locale.ENGLISH));
            decimalFormat.setMaximumFractionDigits(5);

            
            /* Gets latitude, longitude and hemisphere. */
            String latitudeNS=getView().getBuoyLatitudeNS();
            String longitudeEW=getView().getBuoyLongitudeEW();

            Double latitude=Double.parseDouble(latitudeTyped);
            Double longitude=Double.parseDouble(longitudeTyped);

            /* To store coordinates notations. */
            String coordinatesNotation1;
            String coordinatesNotation2;
            String coordinatesNotation3;

            /* Degree symbol no underlined. */
            String degreeSymbol = ""+(char) 176;


            /* First, second and third notation: 
                    - Coordinate using negative / positive number.
                   
                    - Coordinate in NetCDF format:
                        --> Latitude in positive (North) or negative (South) number.
                        --> Longitude in East degrees.
                
                    - Coordinate using hemisphere.                
            */
                if(latitudeNS.equals("S")){

                    /* South: negative */
                    coordinatesNotation1="  Latitude: " + decimalFormat.format((0 - latitude));
                    
                    /* South: negative */
                    coordinatesNotation2="  Latitude: " + decimalFormat.format((0 - latitude));
                    
                    /* Hemisphere. */
                    coordinatesNotation3="  Latitude: " + decimalFormat.format((90 + latitude));
                    
                }else{

                    /* positive */
                    coordinatesNotation1="  Latitude: " + decimalFormat.format(latitude);
                    
                    /* North: positive */
                    coordinatesNotation2="  Latitude: " + decimalFormat.format(latitude);                    
                    
                    /* Hemisphere. */
                    coordinatesNotation3="  Latitude: " + decimalFormat.format(latitude);
                    
                }

                coordinatesNotation1+=degreeSymbol;
                coordinatesNotation2+=degreeSymbol;
                coordinatesNotation3+=degreeSymbol;

                if(longitudeEW.equals("W")){

                    /* negative */
                    coordinatesNotation1+="\tLongitude: " + decimalFormat.format((0 - longitude));
                    
                    /* Longitude in East degrees. */
                    coordinatesNotation2+="\tLongitude: " + decimalFormat.format((360 - longitude));                                        

                    /* Hemisphere. */
                    coordinatesNotation3+="\tLongitude: " + decimalFormat.format((180 + longitude));
                    
                }else{

                    /* positive */
                    coordinatesNotation1+="\tLongitude: " + decimalFormat.format(longitude);
                    
                    /* Longitude in East degrees. */
                    coordinatesNotation2+="\tLongitude: " + decimalFormat.format((180 + longitude));                    

                    /* Hemisphere. */
                    coordinatesNotation3+="\tLongitude: " + decimalFormat.format(longitude);

                }

                coordinatesNotation1+=degreeSymbol;
                coordinatesNotation2+=degreeSymbol;
                coordinatesNotation3+=degreeSymbol;

            /* Sets coordinates notations. */
            getView().setCoordinatesNotations(coordinatesNotation1+"\n\n"+coordinatesNotation2+" (used by reanalysis files)"+"\n\n"+coordinatesNotation3);
                    
        }                
    
    }

    
    /**
     * Closes the view.
     */        
    private void doCancel(){
        
        /* Closes the view. */
        getView().closeView();
    
    }

    
    /**
     * Shows help.
     */            
    private void doHelp(){

        /* Opens pdf file that contains the user manual. */
        
        /* Utilities. */
        Utils util = new Utils();
        
        /* Opens user manual. */
        util.openHelpFile();
            
    }


    
    /**
     * Deletes selected .TXT files by user.
     * @param idBuoy Id of the buoy.
     */    
    private void deleteSelectedFiles(String idBuoy){
        
        /* When modifying a buoy deletes the selected files by user. */
        
        /* Root where the folders are. */
        String root = System.getProperty("user.dir", ".")+File.separator+"DB"
                                  +File.separator+"id"+idBuoy+File.separator+"TXTinFiles";
       
        /* Gets path to the folder. */
           
        File folder = new File(root);
            
        /* Gets files in folder. */
        File[] existingFiles = folder.listFiles();
        
        /* Deletes all existingFiles that are not in filesToCopy (selectd files to be deleted.) */
                
        for (File file : existingFiles){

            int index = alreadySelectedFile(file, getPathFiles());
            
            if(index == -1){
                
                /* The file was not selected to be copied. */
                
                /* Deletes selected file. */
                if (file.delete()){
                    
                    /* success. */
                    JOptionPane.showMessageDialog(null, "The file "+file.getName()+" has been deleted.", "Message", JOptionPane.INFORMATION_MESSAGE);
                    
                }else{
                    
                    JOptionPane.showMessageDialog(null, "The file "+ file.getName()+" could not be deleted.", "Error", JOptionPane.ERROR_MESSAGE);
                
                }
            }else{
                
                /* The file already exists, so it will not be copied. */
                
                getPathFiles().remove(index);
                
            }
        }                       
    }



    /**
     * Calculates the number of .TXT files that belong to the buoy.
     * @param idBuoy Id of the buoy.
     * @return Number of .TXT files that belong to the buoy.
     */    
    private int numTXTFiles(String idBuoy){
        
        /* Returns the number of TXT files of the buoy received. */
        
        /* Root where the folders are. */
        String root = System.getProperty("user.dir", ".")+File.separator+"DB"
                                  +File.separator+"id"+idBuoy+File.separator+"TXTinFiles";

        
        /* Gets path to the folder. */
        File folder = new File(root);
            
        /* Gets files in folder. */
        File[] existingFiles = folder.listFiles();

        /* Returns number of TXT files. */
        return existingFiles.length;
        
    }


    /**
     * Copies selected .TXT files by user.
     * @param idBuoy Id of the buoy.
     */
    private void copySelectedFiles(String idBuoy){
        
        /* After inserting or modifying a buoy, all the selected files are copied. */

        /* Files to be copied. */
        ArrayList<String> files = getPathFiles();

        /* To show files copied in a message. */
        String filesCopied = "";
        
        int size = files.size();

        if(size>0){
            
            for(int index=0;index<size;index++){
                
                /* Source file. */
                File source = new File(files.get(index));

                /* Gets path and filename of target file. */
                String targetFile = System.getProperty("user.dir", ".")+File.separator+"DB"
                              +File.separator+"id"+idBuoy+File.separator+"TXTinFiles"+File.separator+source.getName();
                
                /* Target file. */
                File target = new File(targetFile);
                
                /* Copy the file. */
                if (copyFile(source, target) == false){
                    
                    JOptionPane.showMessageDialog(null, "File "+ source.getName() +" was not be copied.", "Message", JOptionPane.INFORMATION_MESSAGE);
            
                }else{
                    
                    filesCopied = filesCopied + "      " + source.getName() + "\n";

                }
            }
            
            if(filesCopied.isEmpty()==false){
                
                JOptionPane.showMessageDialog(null, "The following files:\n\n"+ filesCopied +"\nhave been copied.", "Message", JOptionPane.INFORMATION_MESSAGE);
            }            
        }    
    }
       

    /**
     * Copies a file.
     * @param source Source file.
     * @param target Target file.
     * @return True if file was properly copied or False if not.
     */
    private boolean copyFile(File source, File target){
        
        /* Copy a TXT file. */
        
        boolean result = false;
        
        try {
            
            if(target.exists()){
                
                Object[] options = {"Cancel", "Overwrite"};
            
                if (JOptionPane.showOptionDialog(null, "Attention !!\nThe selected file "+target.getName()+" already exists.\n"
                        +"¿Do you to want to overwrite it?\n\n","Warning",
                        JOptionPane.DEFAULT_OPTION, JOptionPane.WARNING_MESSAGE, null,options, options[0])==1){
                
                    /* Overwrite the file. */
                    Files.copy(source.toPath(), target.toPath(), REPLACE_EXISTING);
                
                    /* success. */
                    result=true;                
                }
            }else{
                
                Files.copy(source.toPath(), target.toPath());
                
                /* success. */
                result=true;
                
            }
                     
        } catch (IOException ex) {
            Logger.getLogger(ControllerViewBuoyData.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        return result;
    }
    
    
    /**
     * Checks a valid value of latitude coordinate.
     * @param latitude Latitude to check.
     * @return True if the latitude is valid or False if not.
     */
    private boolean isValidLatitude(String latitude){

        /* Regular expression to check latitude. */
        
        String regex="[0-9]{1,3}"+"\\"+".?[0-9]{0,5}";
        
        /* Checks regular expression and range value. */
        boolean result = latitude.matches(regex) && (Double.parseDouble(latitude)>=0.0 && 
                                                     Double.parseDouble(latitude)<=90.0);

        return result;
        
    }
    
    
    /**
     * Checks a valid value of longitude coordinate.
     * @param longitude Longitude to check.
     * @return True if the longitude is valid or False if not.
     */
    private boolean isValidLongitude(String longitude){

        /* Regular expression to check longitude. */
        
        String regex="[0-9]{1,3}"+"\\"+".?[0-9]{0,5}";
        
        /* Checks regular expression and range value. */
        boolean result = longitude.matches(regex) && (Double.parseDouble(longitude)>=0.0 && 
                                                     Double.parseDouble(longitude)<=180.0);

        return result;
        
    }
    
}
